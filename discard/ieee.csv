Document Title,Authors,Author Affiliations,Publication Title,Date Added To Xplore,Publication Year,Volume,Issue,Start Page,End Page,Abstract,ISSN,ISBNs,DOI,Funding Information,PDF Link,Author Keywords,IEEE Terms,INSPEC Controlled Terms,INSPEC Non-Controlled Terms,Mesh_Terms,Article Citation Count,Patent Citation Count,Reference Count,License,Online Date,Issue Date,Meeting Date,Publisher,Document Identifier
Review Sharing via Deep Semi-Supervised Code Clone Detection,C. Guo; H. Yang; D. Huang; J. Zhang; N. Dong; J. Xu; J. Zhu,"College of Computer Science, Nankai University, Tianjin, China; College of Computer Science, Nankai University, Tianjin, China; College of Computer Science, Nankai University, Tianjin, China; College of Artificial Intelligence, Nankai University, Tianjin, China; School of Computing, National University of Singapore, Singapore; College of Artificial Intelligence, Nankai University, Tianjin, China; College of Software, Nankai University, Tianjin, China",IEEE Access,7 Feb 2020,2020,8.0,,24948,24965,"Code review as a typical type of user feedback has recently drawn increasing attentions for improving code quality. To carry out research on code review, sufficient review data is normally required. As a result, recent efforts commonly focus on analysis for projects with sufficient reviews (called “s-projects”), rather than projects with extremely few ones (called “f-projects”). Actually, through statistics on public platforms, the latter ones dominate open source software, in which novel approaches should be explored to improve their review-based code improvement. In this paper, we try to address the problem via building a review sharing channel where the informative review can be reasonably delivered from s-projects to the f-projects. To ensure the accuracy of shared reviews, we introduce a novel code clone detection model based on Convolutional Neural Network (CNN), and build suitable “s-projects, f-projects” pairs through the clone detection. Especially, to alleviate the dataset heterogeneity between the training and testing, an autoencoder-based semi-supervised learning strategy is employed. Furthermore, to improve the sharing experience, heuristic filtering tactics are applied to reduce the time cost. Meanwhile, the LDA (Latent Dirichlet Allocation)-based ranking algorithm is used for presenting diverse review themes. We have implemented the sharing channel as a prototype system RSharer+, which contains three representative modules: data preprocessing, code clone detection and review presentation. The collected datasets are first transformed into context-sensitive numerical vectors in the data proprecessing. Then in the clone detection, data vectors are trained and tested on the BigCloneBench and real code-review pairs. At last, the presentation module provides review classification and theme extraction for better sharing experience. Extensive comparative experiments on hundreds of real labelled code fragments demonstrate the precision of clone detection and the effectiveness of review sharing.",2169-3536,,10.1109/ACCESS.2020.2966532,"Science and Technology Planning Project of Tianjin, China(grant numbers:17JCZDJC30700,17YFZCGX00610,18ZXZNGX00310); Natural Science Foundation of Tianjin City(grant numbers:19JCQNJC00300); Fundamental Research Funds for the Central Universities(grant numbers:63191402); ",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8959206,Code clone;software review;deep learning;semi-supervised CNN;review sharing,Cloning;Deep learning;Computational modeling;Syntactics;Computer bugs;Software;Testing,convolutional neural nets;learning (artificial intelligence);public domain software;software maintenance;software quality,RSharer+;sharing channel;latent Dirichlet allocation-based ranking algorithm;heuristic filtering tactics;f-projects;s-projects;CNN;convolutional neural network;user feedback;labelled code fragments;review classification;real code-review pairs;diverse review themes;LDA-based ranking algorithm;sharing experience;autoencoder-based semisupervised learning strategy;novel code clone detection model;shared reviews;informative review;review sharing channel;review-based code improvement;sufficient review data;code quality;code review;deep semisupervised code clone detection,,2.0,,73.0,CCBY,14 Jan 2020,,,IEEE,IEEE Journals
A Feasibility Study of Using Code Clone Detection for Secure Programming Education,M. Menard; T. Nelson; M. Shahi; H. Morton; A. DeTavernier; H. Siy; R. Zhao; M. Song,"Dept. of Computer Science, University of Nebraska at Omaha, USA; Dept. of Computer Science, University of Nebraska at Omaha, USA; Dept. of Computer Science, University of Nebraska at Omaha, USA; Dept. of Computer Science, University of Nebraska at Omaha, USA; Dept. of Computer Science, University of Nebraska at Omaha, USA; Dept. of Computer Science, University of Nebraska at Omaha, USA; Dept. of Computer Science, University of Nebraska at Omaha, USA; Dept. of Computer Science, University of Nebraska at Omaha, USA","2022 IEEE 46th Annual Computers, Software, and Applications Conference (COMPSAC)",10 Aug 2022,2022,,,1502,1507,"Secure library reuse is critical for modern ap-plications to protect private information in software security engineering. Teaching secure programming is also more critical to tackle the challenges of new and evolving threats. However, novice students often make mistakes by API misuses due to a lack of understanding of secure libraries or a false sense of security. In this paper, we study the feasibility of applying code clone detection (CCD) for finding relevant examples to effectively teach secure programming to computer science students. CCD is an emerging new technology that extracts syntactically or semantically similar code fragments to support many software engineering tasks, such as program understanding, code quality analysis, software evolution analysis, and bug detection. We have developed a prototype implementation ExTUTOR that allows students to search for relevant examples as feedback when they want to fix their programming issues or vulnerabilities. In our evaluation, we applied ExTUTOR to open source subject applications in the security domain. Our approach should help novice students gain benefits from feedback and identify how to effectively make use of APIs, encouraging students to fix their own security violations in their own applications.",0730-3157,978-1-6654-8810-5,10.1109/COMPSAC54236.2022.00238,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9842461,Code Clone Detection;Computer Science Education;Secure Programming,Charge coupled devices;Codes;Education;Cloning;Software;Libraries;Velocity measurement,application program interfaces;computer aided instruction;computer science education;program debugging;program diagnostics;programming;reverse engineering;security of data;software engineering;software maintenance;teaching,program understanding;code quality analysis;software evolution analysis;bug detection;relevant examples;programming issues;security domain;novice students gain benefits;security violations;code clone detection;secure programming education;secure library reuse;modern ap-plications;private information;software security engineering;secure libraries;CCD;computer science students;semantically similar code fragments;software engineering tasks,,,,29.0,IEEE,10 Aug 2022,,,IEEE,IEEE Conferences
Transferring Code-Clone Detection and Analysis to Practice,Y. Dang; D. Zhang; S. Ge; R. Huang; C. Chu; T. Xie,"Microsoft Corporation, USA; Microsoft Research Asia, China; Microsoft Research Asia, China; Microsoft Research Asia, China; Microsoft Corporation, USA; University of Illinois at Urbana-Champaign, USA",2017 IEEE/ACM 39th International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP),3 Jul 2017,2017,,,53,62,"During software development, code clones are commonly produced, in the form of a number of the same or similar code fragments spreading within one or many large code bases. Numerous research projects have been carried out on empirical studies or tool support for detecting or analyzing code clones. However, in practice, few such research projects have resulted in substantial industry adoption. In this paper, we report our experiences of transferring XIAO, a code-clone detection and analysis approach and its supporting tool, to road industrial practices: (1) shipped in Visual Studio 2012, a widely used industrial IDE, (2) deployed and intensively used at the Microsoft Security Response Center. According to our experiences, technology transfer is a rather complicated journey that needs significant efforts from both the technical aspect and social aspect. From the technical aspect, significant efforts are needed to adapt a research prototype to a product-quality tool that addresses the needs of real scenarios, to be integrated into a mainstream product or development process. From the social aspect, there are strong needs to interact with practitioners to identify killer scenarios in industrial settings, figure out the gap between a research prototype and a tool fitting the needs of real scenarios, to understand the requirements of releasing with a mainstream product, being integrated into a development process, understanding their release cadence, etc.",,978-1-5386-2717-4,10.1109/ICSE-SEIP.2017.6,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7965429,,Cloning;Visualization;Computer bugs;Tools;Security;Software;Electronic mail,program diagnostics;programming environments;social aspects of automation;software quality;source code (software),code-clone detection;code-clone analysis;software development;code fragments;tool support;XIAO;Visual Studio 2012;industrial IDE;Microsoft Security Response Center;social aspect;technical aspect;product-quality tool;tool fitting,,12.0,,21.0,,3 Jul 2017,,,IEEE,IEEE Conferences
Rearranging the order of program statements for code clone detection,Y. Sabi; Y. Higo; S. Kusumoto,"Graduate School of Information Science and Technology, Osaka University, Japan; Graduate School of Information Science and Technology, Osaka University, Japan; Graduate School of Information Science and Technology, Osaka University, Japan",2017 IEEE 11th International Workshop on Software Clones (IWSC),20 Mar 2017,2017,,,1,7,"A code clone is a code fragment identical or similar to another code fragment in source code. Some of code clones are considered as a factor of bug replications and make it more difficult to maintain software. Various code clone detection tools have been proposed so far. However, in most algorithms adopted by existing clone detection tools, if program statements are reordered, they are not detected as code clones. In this research, we examined how clone detection results change by rearranging the order of program statements. We performed preprocessing to rearranging the order of program statements using program dependency graph (PDG). We compared clone detection results with and without preprocessing. As a result, by rearranging the order of program statements, the number of detected code clones is almost the same in most projects. We classified newly detected or disappeared clones manually. From our experimental results, we show that there is no newly detected clone whose statements are reordered and that there are four disappeared clones whose statements are reordered. We think three out of the four clones occurred by copy-and-paste operations. Therefore, we conclude that rearranging the order of program statements is not effective to detect reordered code clones.",,978-1-5090-6595-0,10.1109/IWSC.2017.7880503,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7880503,,Cloning;Software algorithms;Software;Terminology;Computer bugs;Java;Information science,graph theory;program debugging;software tools;source code (software),program statement order rearrangement;code fragment;source code;bug replications;code clone detection tools;program dependency graph;PDG;copy-and-paste operations,,4.0,,14.0,,20 Mar 2017,,,IEEE,IEEE Conferences
Refactoring Code Clone Detection,Z. Sarkawt OTHMAN; M. KAYA,"Software Engineering, Firat University, Elazig, Turkey; Electrics Engineering, Adiyaman University, Adiyaman, Turkey",2019 7th International Symposium on Digital Forensics and Security (ISDFS),11 Jul 2019,2019,,,1,6,"Refactoring duplicate code is an important issue and is one of the most important smells in software maintenance. There is an important relationship between clones and code quality. Most programmers use clones because they are cheaper and faster than typing the program code. A cloning code is created by copying and pasting the existing code fragments of the source code with or without slight modifications. A major part (5% to 10%) of the source code for large computer programs consists of copy codes. Since cloning is believed to reduce the possibility of software maintenance, many techniques and cloning detection tools have been recommended for this purpose. The basic goal of clone detection is to identify the clone code and replace it with a single call to the function, where the function simulates the behavior of one instance of the clone group. This research provides an overview of the refactoring IDE. The aspects of cloning and detection of cloning are explained. In the copy detection algorithm, the source code is created in XML format.",,978-1-7281-2827-6,10.1109/ISDFS.2019.8757479,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8757479,Refactoring;Code Clone;Clone Detection,Cloning;Tools;Software maintenance;Detection algorithms;Maintenance engineering;Detectors,program compilers;software maintenance;XML,copy detection algorithm;source code;code clone detection;duplicate code;software maintenance;code quality;program code;cloning code;copy codes;clone group;code fragments,,,,19.0,,11 Jul 2019,,,IEEE,IEEE Conferences
Toxic Code Snippets on Stack Overflow,C. Ragkhitwetsagul; J. Krinke; M. Paixao; G. Bianco; R. Oliveto,"Computer Science, Faculty of Information and Communication Technology, Mahidol University, Salaya, Thailand; Computer Science, University College London, London, United Kingdom; Computer Science, Universidade Estadual do Ceara, Fortaleza, Brazil; Computer Science, Universita degli Studi del Molise, Campobasso, Italy; Department of Bioscience and Territory, University of Molise, Pesche, Italy",IEEE Transactions on Software Engineering,15 Mar 2021,2021,47.0,3.0,560,581,"Online code clones are code fragments that are copied from software projects or online sources to Stack Overflow as examples. Due to an absence of a checking mechanism after the code has been copied to Stack Overflow, they can become toxic code snippets, e.g., they suffer from being outdated or violating the original software license. We present a study of online code clones on Stack Overflow and their toxicity by incorporating two developer surveys and a large-scale code clone detection. A survey of 201 high-reputation Stack Overflow answerers (33 percent response rate) showed that 131 participants (65 percent) have ever been notified of outdated code and 26 of them (20 percent) rarely or never fix the code. 138 answerers (69 percent) never check for licensing conflicts between their copied code snippets and Stack Overflow's CC BY-SA 3.0. A survey of 87 Stack Overflow visitors shows that they experienced several issues from Stack Overflow answers: mismatched solutions, outdated solutions, incorrect solutions, and buggy code. 85 percent of them are not aware of CC BY-SA 3.0 license enforced by Stack Overflow, and 66 percent never check for license conflicts when reusing code snippets. Our clone detection found online clone pairs between 72,365 Java code snippets on Stack Overflow and 111 open source projects in the curated Qualitas corpus. We analysed 2,289 non-trivial online clone candidates. Our investigation revealed strong evidence that 153 clones have been copied from a Qualitas project to Stack Overflow. We found 100 of them (66 percent) to be outdated, of which 10 were buggy and harmful for reuse. Furthermore, we found 214 code snippets that could potentially violate the license of their original software and appear 7,112 times in 2,427 GitHub projects.",1939-3520,,10.1109/TSE.2019.2900307,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8643998,Code clone detection;stack overflow;outdated code;software licensing,Cloning;Licenses;Software;Programming;Computer bugs;Security;Tutorials,Java;public domain software;software reusability,toxic code snippets;online code clones;code fragments;large-scale code clone detection;high-reputation Stack Overflow answerers;outdated code;Stack Overflow answers;buggy code;Java code snippets;code snippet reusing;Stack Overflow's CC BY-SA 3.0 license;software project;curated Qualitas corpus;efficiency 20.0 percent;efficiency 69.0 percent;efficiency 85.0 percent;efficiency 66.0 percent;efficiency 33.0 percent;efficiency 65.0 percent,,28.0,,82.0,IEEE,19 Feb 2019,,,IEEE,IEEE Journals
InferCode: Self-Supervised Learning of Code Representations by Predicting Subtrees,N. D. Q. Bui; Y. Yu; L. Jiang,"School of Computing & Information Systems, Singapore Management Univerity; School of Computing & Communications, The Open University, UK; School of Computing & Information Systems, Singapore Management Univerity",2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE),7 May 2021,2021,,,1186,1197,"Learning code representations has found many uses in software engineering, such as code classification, code search, comment generation, and bug prediction, etc. Although representations of code in tokens, syntax trees, dependency graphs, paths in trees, or the combinations of their variants have been proposed, existing learning techniques have a major limitation that these models are often trained on datasets labeled for specific downstream tasks, and as such the code representations may not be suitable for other tasks. Even though some techniques generate representations from unlabeled code, they are far from being satisfactory when applied to the downstream tasks. To overcome the limitation, this paper proposes InferCode, which adapts the self-supervised learning idea from natural language processing to the abstract syntax trees (ASTs) of code. The novelty lies in the training of code representations by predicting subtrees automatically identified from the contexts of ASTs. With InferCode, subtrees in ASTs are treated as the labels for training the code representations without any human labelling effort or the overhead of expensive graph construction, and the trained representations are no longer tied to any specific downstream tasks or code units. We have trained an instance of InferCode model using Tree-Based Convolutional Neural Network (TBCNN) as the encoder of a large set of Java code. This pre-trained model can then be applied to downstream unsupervised tasks such as code clustering, code clone detection, cross-language code search, or be reused under a transfer learning scheme to continue training the model weights for supervised tasks such as code classification and method name prediction. Compared to prior techniques applied to the same downstream tasks, such as code2vec, code2seq, ASTNN, using our pre-trained InferCode model higher performance is achieved with a significant margin for most of the tasks, including those involving different programming languages. The implementation of InferCode and the trained embeddings are available at the link: https://github.com/bdqnghi/infercode.",1558-1225,978-1-6654-0296-5,10.1109/ICSE43902.2021.00109,Ministry of Education; Royal Society; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9402028,code search;self supervised;code clone detection;cross language;fine tuning;code retrieval;unlabel data;unlabelled data,Training;Computer bugs;Cloning;Predictive models;Syntactics;Task analysis;Software engineering,computational linguistics;convolutional neural nets;Java;supervised learning;trees (mathematics),pre-trained InferCode model;subtrees prediction;trained representations;unlabeled code;specific downstream tasks;code representations;code2seq;code classification;cross-language code search;code clone detection;code clustering;Java code;code units,,10.0,,71.0,,7 May 2021,,,IEEE,IEEE Conferences
GENES ISP: code analysis platform,S. Sargsyan; V. Vardanyan; H. Aslanyan; M. Harutunyan; M. Mehrabyan; K. Sargsyan; H. Hovahannisyan; H. Movsisyan; J. Hakobyan; S. Kurmangaleev,"Russian-Armenian Slavonic University, Yerevan, Armenia; Russian-Armenian Slavonic University, Yerevan, Armenia; Russian-Armenian Slavonic University, Yerevan, Armenia; Russian-Armenian Slavonic University, Yerevan, Armenia; Russian-Armenian Slavonic University, Yerevan, Armenia; Russian-Armenian Slavonic University, Yerevan, Armenia; Russian-Armenian Slavonic University, Yerevan, Armenia; Russian-Armenian Slavonic University, Yerevan, Armenia; Russian-Armenian Slavonic University, Yerevan, Armenia; ISP RAS, Moscow, Russia",2020 Ivannikov Ispras Open Conference (ISPRAS),12 Apr 2021,2020,,,35,39,"In this paper we present a novel code analysis platform referred as “GENESISP”. Its aim is to collect vast database of open source software and apply several integrated analyses. This analysis allows to understand relations within source and binary code, as well as detect existing defects. All the analyses are compatible with each other and can be combined, which provides more robust possibilities. In the first stage the framework tries to collect, process and store software related data into database. Various open source resources are used for that purpose. For open source software, we collect and store: source and binary code, debug information, build dependencies, linker commands, confirmed CVE and their possible fixes, etc. For operating systems distributions, we additionally store the list of available software packages. In the second stage the tool performs various analysis: source code clone detection, binary code clone detection, source/binary fragments search, statically linked libraries identification in binaries, unfixed CVE search, source and binary code matching, patch analysis, etc. We provide web interface for convenient use of the provided analyses. Beside it, there is an interactive terminal which enables users to query the database and combine the results of different analysis. We were able to find number of confirmed CVE in mainstream versions of different open source software, which proves the effectiveness of proposed platform.",,978-1-6654-1291-9,10.1109/ISPRAS51486.2020.00012,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9394122,GENESISP;code analysis;code clones;patch analysis;code query;binary code analysis;vulnerability detection,Databases;Operating systems;Cloning;Binary codes;Tools;Libraries;Open source software,binary codes;Internet;operating systems (computers);program compilers;program debugging;program diagnostics;public domain software;software libraries;software maintenance;software packages;source code (software);source coding,source code clone detection;binary code clone detection;binary code matching;patch analysis;provided analyses;different analysis;confirmed CVE;different open source software;GENES ISP;code analysis platform;vast database;integrated analyses;store software;open source resources;available software packages,,1.0,,34.0,,12 Apr 2021,,,IEEE,IEEE Conferences
Tracking Method-Level Clones and a Case Study,K. Uemura; A. Mori; E. Choi; H. Iida,"Nara Institute of Science and Technology, Japan; National Institute of Advanced Industrial Science and Technology, Japan; Nara Institute of Science and Technology, Japan; Nara Institute of Science and Technology, Japan",2019 IEEE 13th International Workshop on Software Clones (IWSC),14 Mar 2019,2019,,,27,33,"Analyzing histories of code clones is important for understanding how they affect software development and developers. For this, many studies have been devoted to the approach of tracking code clones. However, to the best of our knowledge, no existing studies have attempted to track code clones in long-term and fine-grained change histories.In this paper, we report on the analysis of histories of method-level code clones hosted by a fine-grained version control system called historage, which allowed us to track source code entities across commits.We have tracked and analyzed method-level code clones in 10 open source software projects and found out that (1) in many projects, method-level code clones are removed regardless of whether they were changed or how frequently they were changed, and (2) a group of method-level code clones created at the same time tend to survive longer than those created individually. We believe that these findings will provide useful insights for future research on code clones such as determining the priority of code clone management.",2572-6587,978-1-7281-1805-5,10.1109/IWSC.2019.8665851,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8665851,code clone;code clone detection;code clone genealogy;mining software repository,Cloning;History;Syntactics;Software;Target tracking;Tools,configuration management;project management;public domain software;software maintenance;software management;source coding,method-level code clones;source code entities;code clone management;software project management;open source software projects;historage;version control system;software development;code clone tracking,,2.0,,16.0,,14 Mar 2019,,,IEEE,IEEE Conferences
MoCoP: Towards a Model Clone Portal,Ö. Babur; M. Stephan,"Dept. of Mathematics & Computer Science, Eindhoven University of Technology, Eindhoven, The Netherlands; Dept. of Computer Science & Software Engineering, Miami University, Oxford, Ohio, USA",2019 IEEE/ACM 11th International Workshop on Modelling in Software Engineering (MiSE),21 Oct 2019,2019,,,78,81,"Widespread and mature practice of model-driven engineering is leading to a growing number of modeling artifacts and challenges in their management. Model clone detection (MCD) is an important approach for managing and maintaining modeling artifacts. While its counterpart in traditional source code development, code clone detection, is enjoying popularity and more than two decades of development, MCD is still in its infancy in terms of research and tooling. We aim to develop a portal for model clone detection, MoCoP, as a central hub to mitigate adoption barriers and foster MCD research. In this short paper, we present our vision for MoCoP and its features and goals. We discuss MoCoP's key components that we plan on realizing in the short term including public tooling, curated data sets, and a body of MCD knowledge. Our longer term goals include a dedicated service-oriented infrastructure, contests, and forums. We believe MoCoP will strengthen MCD research, tooling, and the community, which in turn will lead to better quality, maintenance, and scalability for model-driven engineering practices.",2575-4475,978-1-7281-2231-1,10.1109/MiSE.2019.00019,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8877032,"model-driven engineering, model clone detection, model analytics, software maintenance, model management, model repositories",Unified modeling language;Cloning;Tools;Analytical models;Portals;Charge coupled devices;Software,portals;software architecture;software maintenance,managing maintaining modeling artifacts;traditional source code development;code clone detection;model clone detection;foster MCD research;MCD knowledge;model-driven engineering practices;model clone portal;mature practice;MoCoP key components,,,,34.0,,21 Oct 2019,,,IEEE,IEEE Conferences
Mapping Similarity Detectors of Code Clone to Academic Integrity in Programming,M. A. Pangestu; O. Karnalim; Simon,"University of Newcastle, Callaghan, Australia; University of Newcastle, Callaghan, Australia; University of Newcastle, Callaghan, Australia",2021 IEEE World Conference on Engineering Education (EDUNINE),19 May 2021,2021,,,1,6,"When dealing with academic integrity in programming, code similarity detectors are often used to raise suspicion of student programs with undue similarity. However, it appears that only detectors designed for that purpose are discussed in computing education publications, although similarity detectors for other purposes might also be beneficial, both to foster research and to avoid `reinventing the wheel'. This paper maps similarity detectors used to identify code clones, repeated code segments in a software system, to the classifications used for academic integrity purposes. It will help academic integrity researchers to understand code clone similarity detectors and to read papers from that area. While there are other reviews of code clone detection, ours should be easier for computing educators to read as it uses the terminologies of academic integrity.",,978-1-6654-0302-3,10.1109/EDUNINE51952.2021.9429164,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9429164,code similarity detection;code clone;academic integrity;programming;computing education,Terminology;Conferences;Cloning;Detectors;Software systems;Engineering education;Programming profession,computer science education;educational administrative data processing;program diagnostics;programming,code clone detection;code similarity detectors;student programs;repeated code segments;academic integrity researchers;code clone similarity detectors;similarity detector mapping,,,,57.0,,19 May 2021,,,IEEE,IEEE Conferences
CATE: Concolic Android Testing Using Java PathFinder for Android Applications,P. McAfee; M. Wiem Mkaouer; D. E. Krutz,"Department of Software Engineering, Rochester Institute of Technology, Rochester, NY, USA; Department of Software Engineering, Rochester Institute of Technology, Rochester, NY, USA; Department of Software Engineering, Rochester Institute of Technology, Rochester, NY, USA",2017 IEEE/ACM 4th International Conference on Mobile Software Engineering and Systems (MOBILESoft),11 Jul 2017,2017,,,213,214,"Like all software, Android applications are not immune to bugs, security vulnerabilities, and a wide range of other issues. Concolic analysis, a hybrid software verification technique which performs symbolic execution along with a concrete execution path, has been used for a variety of purposes including software testing, code clone detection, and security-related activities. We created a new publicly available concolic analysis tool for analyzing Android applications: Concolic Android TEster (CATE). Building on Java Path Finder (JPF-SPF), this tool performs concolic analysis on a raw Android application file (or source code) and provides output in a useful and easy to understand format.",,978-1-5386-2669-6,10.1109/MOBILESoft.2017.35,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7972811,,Androids;Humanoid robots;Tools;Java;Cloning;Testing;Libraries,Android (operating system);Java;mobile computing;program testing;program verification;security of data,concolic analysis tool;code clone detection;software testing;symbolic execution;hybrid software verification technique;security vulnerabilities;Android applications;JPF-SPF;Java PathFinder;concolic Android tester;CATE,,2.0,,5.0,,11 Jul 2017,,,IEEE,IEEE Conferences
PHANTA: Diversified Test Code Quality Measurement for Modern Software Development,S. Tokumoto; K. Takayama,"Fujitsu Laboratories Ltd., Japan; Fujitsu Laboratories Ltd., Japan",2019 34th IEEE/ACM International Conference on Automated Software Engineering (ASE),9 Jan 2020,2019,,,1206,1207,"Test code is becoming more essential to the modern software development process. However, practitioners often pay inadequate attention to key aspects of test code quality, such as bug detectability, maintainability and speed. Existing tools also typically report a single test code quality measure, such as code coverage, rather than a diversified set of metrics. To measure and visualize quality of test code in a comprehensive fashion, we developed an integrated test code analysis tool called Phanta. In this show case, we posit that the enhancement of test code quality is key to modernizing software development, and show how Phanta's techniques measure the quality using mutation analysis, test code clone detection, and so on. Further, we present an industrial case study where Phanta was applied to analyze test code in a real Fujitsu project, and share lessons learned from the case study.",2643-1572,978-1-7281-2508-4,10.1109/ASE.2019.00138,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8952538,Software Testing;Test Code;Mutation Testing,Tools;Measurement;Cloning;Software;Testing;Computer bugs;Software engineering,program testing;software maintenance;software quality,diversified test code quality measurement;modern software development process;single test code quality measure;code coverage;integrated test code analysis tool;software development;test code clone detection;Phanta techniques measure;mutation analysis;Fujitsu project,,,,6.0,,9 Jan 2020,,,IEEE,IEEE Conferences
Towards Informative Tagging of Code Fragments to Support the Investigation of Code Clones,D. Nishioka; T. Kamiya,"Department of Information Systems Design and Data Science, Grad. Sch. of Natural Sci. & Tech., Shimane Univ, Matsue, Japan; Institute of Sci. & Eng., Shimane Univ, Matsue, Japan",2021 IEEE 15th International Workshop on Software Clones (IWSC),20 Jan 2022,2021,,,8,14,"Investigating the code fragments of code clones detected by code clone detection tools is a time-consuming task, especially when a large number of reference source files are available. This paper proposes (i) a method for clustering a clone class, which is detected by code clone detection tools using syntactic similarity, based on topic similarity by considering its code fragments as sequences of words and (ii) a method for assigning short tags to clusters of the clustering result. We also report an experiment of applying the proposed method to packages of an open source operating system.",2572-6587,978-1-6654-4287-9,10.1109/IWSC53727.2021.00008,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9679791,Program analysis;Tools;Code inspections and walkthroughs;Software maintenance,Codes;Operating systems;Cloning;Focusing;Tagging;Syntactics;Maintenance engineering,operating systems (computers);pattern clustering;public domain software;source code (software),code clone detection tools;code fragments;informative tagging;reference source files;open source operating system,,,,53.0,IEEE,20 Jan 2022,,,IEEE,IEEE Conferences
On The Cross-Modal Transfer from Natural Language to Code through Adapter Modules,D. Goel; R. Grover; F. H. Fard,"Indian Institute of Technology, Roorkee, India; Delhi Technological University, Delhi, India; University of British Columbia, Canada",2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC),22 Jun 2022,2022,,,71,81,"Pre-trained neural Language Models (PTLM), such as CodeBERT, are recently used in software engineering as models pre-trained on large source code corpora. Their knowledge is transferred to downstream tasks (e.g. code clone detection) via fine-tuning. In natural language processing (NLP), other alternatives for transferring the knowledge of PTLMs are explored through using adapters, compact, parameter efficient modules inserted in the layers of the PTLM. Although adapters are known to facilitate adapting to many downstream tasks compared to fine-tuning the model that require retraining all of the models' parameters- which owes to the adapters' plug and play nature and being parameter efficient-their usage in software engineering is not explored. Here, we explore the knowledge transfer using adapters and based on the Naturalness Hypothesis proposed by Hindle et. al [12]. Thus, studying the bimodality of adapters for two tasks of cloze test and code clone detection, compared to their benchmarks from the CodeXGLUE platform. These adapters are trained using programming languages and are inserted in a PTLM that is pre-trained on English corpora (N-PTLM). Three programming languages, $\mathrm{C}/\mathrm{C}++$, Python, and Java, are studied along with extensive experiments on the best setup used for adapters. Improving the results of the N-PTLM confirms the success of the adapters in knowledge transfer to software engineering, which sometimes are in par with or exceed the results of a PTLM trained on source code; while being more efficient in terms of the number of parameters, memory usage, and inference time. Our results can open new directions to build smaller models for more software engineering tasks. We open source all the scripts and the trained adapters.",2643-7171,978-1-4503-9298-3,10.1145/3524610.3527892,Natural Sciences and Engineering Research Council of Canada(grant numbers:RGPIN-2019-05175); ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796334,Pre-trained Language Models;Transfer learning;Adapters;Parameter Efficient Models,Adaptation models;Codes;Memory management;Cloning;Natural language processing;Task analysis;Knowledge transfer,Java;natural language processing;programming languages;Python;software engineering,cross-modal transfer;adapter modules;pre-trained neural language models;source code corpora;code clone detection;natural language processing;parameter efficient modules;knowledge transfer;programming languages;N-PTLM;trained adapters;open source;C/C++;Python;Java;CodeXGLUE platform;software engineering,,,,35.0,,22 Jun 2022,,,IEEE,IEEE Conferences
How Compact Will My System Be? A Fully-Automated Way to Calculate LoC Reduced by Clone Refactoring,T. Nakagawa; Y. Higo; J. Matsumoto; S. Kusumoto,"Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan; Graduate School of Information Science and Technology, Osaka University, Suita, Osaka, Japan",2019 26th Asia-Pacific Software Engineering Conference (APSEC),2 Jan 2020,2019,,,284,291,"A code clone (in short, clone) is a code fragment that is identical or similar to other code fragments in source code. The presence of clone is known as bad smell, which is phenomena of source code to be refactored. A motivation of refactoring (merging) clones is to reduce the size of source code. An existing study proposed a technique to estimate reduced lines of code by merging clones; however, there are two issues in the existing technique: (1) the existing technique does not consider the refactorability of clones in spite that it is difficult or even impossible to merge some clones due to the limitation of programming languages; (2) in the case that multiple clones are overlapping, the existing technique only considers one of them can be merged. Due to the above issues, estimated reducible LoC is occasionally different from the actual number. Consequently, in this research, we propose a new technique to calculate a reducible LoC. The proposed technique is free from the two issues, and it calculates a reducible LoC fully automatically. The proposed technique performs a loop processing of (a) detecting clones, (b) merging them, (c) compiling the edited source files, and (d) testing them. After finishing the loop, reducible LoC is calculated from the edited source files. This paper also includes comparison results of the proposed technique and the existing one. In the comparisons, we confirmed that a reducible LoC which was calculated with considering refactorability is 25% of a reducible LoC which was estimated without considering refactorability. We also confirmed that the proposed technique was able to merge clones that were not counted in the existing technique.",2640-0715,978-1-7281-4648-5,10.1109/APSEC48747.2019.00046,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8945738,Software maintenance;code clone;refactoring,Cloning;Merging;Computer languages;Maintenance engineering;Tools;Testing;Software systems,program compilers;software maintenance;source code (software),LoC;clone refactoring;code clone;code fragment;source code;clone detection;refactorability;software maintenance,,2.0,,17.0,,2 Jan 2020,,,IEEE,IEEE Conferences
Deep Review Sharing,C. Guo; D. Huang; N. Dong; Q. Ye; J. Xu; Y. Fan; H. Yang; Y. Xu,"Department of Computer Science, Nankai University, China; Department of Computer Science, Nankai University, China; Department of Computing, National University of Singapore, Singapore; Advanced Digital Sciences Center, Singapore; Department of Artificial Intelligence, Nankai University, China; Department of Computer Science, Nankai University, China; Department of Computer Science, Nankai University, China; Department of Computer Science, Nankai University, China","2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)",18 Mar 2019,2019,,,61,72,"Review-Based Software Improvement (RBSI for short) has drawn increasing research attentions in recent years. Relevant efforts focus on how to leverage the underlying information within reviews to obtain a better guidance for further updating. However, few efforts consider the Projects Without sufficient Reviews (PWR for short). Actually, PWR dominates the software projects, and the lack of PWR-based RBSI research severely blocks the improvement of certain software. In this paper, we make the first attempt to pave the road. Our goal is to establish a generic framework for sharing suitable and informative reviews to arbitrary PWR. To achieve this goal, we exploit techniques of code clone detection and review ranking. In order to improve the sharing precision, we introduce Convolutional Neural Network (CNN) into our clone detection, and design a novel CNN based clone searching module for our sharing system. Meanwhile, we adopt a heuristic filtering strategy to reduce the sharing time cost. We implement a prototype review sharing system RSharer and collect 72,440 code-review pairs as our ground knowledge. Empirical experiments on hundreds of real code fragments verify the effectiveness of RSharer. RSharer also achieves positive response and evaluation by expert developers.",1534-5351,978-1-7281-0591-8,10.1109/SANER.2019.8668037,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8668037,code clone;software review;deep learning;CNN,Cloning;Software;Deep learning;Syntactics;Computer bugs;Software reviews;Training,convolutional neural nets;software development management;software maintenance;software reviews;source code (software),code clone detection;prototype review sharing system;deep review sharing;RBSI;PWR;convolutional neural network;projects without sufficient reviews;review-based software improvement;CNN,,6.0,,59.0,,18 Mar 2019,,,IEEE,IEEE Conferences
Studying Duplicate Logging Statements and Their Relationships With Code Clones,Z. Li; T. -H. Chen; J. Yang; W. Shang,"Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada; Department of Computer Science and Software Engineering, Concordia University, Montreal, QC, Canada",IEEE Transactions on Software Engineering,15 Jul 2022,2022,48.0,7.0,2476,2494,"Developers rely on software logs for a variety of tasks, such as debugging, testing, program comprehension, verification, and performance analysis. Despite the importance of logs, prior studies show that there is no industrial standard on how to write logging statements. In this paper, we focus on studying duplicate logging statements, which are logging statements that have the same static text message. Such duplications in the text message are potential indications of logging code smells, which may affect developers’ understanding of the dynamic view of the system. We manually studied over 4K duplicate logging statements and their surrounding code in five large-scale open source systems: Hadoop, CloudStack, Elasticsearch, Cassandra, and Flink. We uncovered five patterns of duplicate logging code smells. For each instance of the duplicate logging code smell, we further manually identify the potentially problematic (i.e., require fixes) and justifiable (i.e., do not require fixes) cases. Then, we contact developers to verify our manual study result. We integrated our manual study result and developers’ feedback into our automated static analysis tool, DLFinder, which automatically detects problematic duplicate logging code smells. We evaluated DLFinder on the five manually studied systems and three additional systems: Camel, Kafka and Wicket. In total, combining the results of DLFinder and our manual analysis, we reported 91 problematic duplicate logging code smell instances to developers and all of them have been fixed. We further study the relationship between duplicate logging statements, including the problematic instances of duplicate logging code smells, and code clones. We find that 83 percent of the duplicate logging code smell instances reside in cloned code, but 17 percent of them reside in micro-clones that are difficult to detect using automated clone detection tools. We also find that more than half of the duplicate logging statements reside in cloned code snippets, and a large portion of them reside in very short code blocks which may not be effectively detected by existing code clone detection tools. Our study shows that, in addition to general source code that implements the business logic, code clones may also result in bad logging practices that could increase maintenance difficulties.",1939-3520,,10.1109/TSE.2021.3060918,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9360483,Log;code smell;duplicate log;code clone;static analysis;empirical study,Cloning;Manuals;Tools;Static analysis;Maintenance engineering;Java;Cloud computing,program debugging;program diagnostics;public domain software;software maintenance,duplicate logging statements;code clone detection tools;bad logging practices;software logs;problematic duplicate logging code smell instances;Hadoop;CloudStack;Elasticsearch;Cassandra;Flink;automated static analysis tool;DLFinder;business logic,,2.0,,82.0,IEEE,22 Feb 2021,,,IEEE,IEEE Journals
BCFinder: A Lightweight and Platform-Independent Tool to Find Third-Party Components in Binaries,W. Tang; D. Chen; P. Luo,"State Key Laboratory of Information Security, Tsinghua University, Beijing, China; State Key Laboratory of Information Security, Tsinghua University, Beijing, China; State Key Laboratory of Information Security, Tsinghua University, Beijing, China",2018 25th Asia-Pacific Software Engineering Conference (APSEC),23 May 2019,2018,,,288,297,"Open source movement boosts several open source communities and millions of open source repositories (repos) are available on these communities. Consequently, component-based development and code reuse greatly improve the efficiency of software development. However, they can also bring some problems, such as license violation and security weaknesses. While code reuse detection has been extensively studied in source form, third-party components detection for software in binary form especially based on large scale database like Github has been less researched. In this paper, we take a series of data cleaning processes to get filtered 22K C/C++ repos on Github. We extend the code reuse detection for binaries against such a large-scale data set and design a system called BCFinder as an assistant tool for binary analysis. BCFinder finds third-party components in binaries automatically by feature matching. We evaluate BCFinder with a number of real-word binary programs across platform and compiling configurations. Experiments show that BCFinder is an effective supplementary tool for binary analysis. BCFinder is, by far, the first lightweight, rapid and platform-independent tool to detect component reuse in binaries against a large-scale data base like Github.",2640-0715,978-1-7281-1970-0,10.1109/APSEC.2018.00043,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8719473,code clone detection;binary analysis;license violation;application security,Tools;Databases;Software;Feature extraction;Licenses;Cloning;Java,data handling;object-oriented programming;public domain software;security of data;software reusability,BCFinder;open source repositories;repos;component-based development;software development;license violation;security weaknesses;code reuse detection;third-party components detection;Github;assistant tool;binary analysis;compiling configurations;component reuse;large-scale data base;lightweight platform-independent tool;binary programs;22K C-C++ repos;data cleaning processes,,7.0,,36.0,,23 May 2019,,,IEEE,IEEE Conferences
Scalable Framework for Accurate Binary Code Comparison,H. Aslanyan; A. Avetisyan; M. Arutunian; G. Keropyan; S. Kurmangaleev; V. Vardanyan,"Compiler Technology Department, ISPRAS, Moscow, Russia; Compiler Technology Department, ISPRAS, Moscow, Russia; Compiler Technology Department, ISPRAS, Moscow, Russia; Compiler Technology Department, ISPRAS, Moscow, Russia; Compiler Technology Department, ISPRAS, Moscow, Russia; Compiler Technology Department, ISPRAS, Moscow, Russia",2017 Ivannikov ISPRAS Open Conference (ISPRAS),1 Feb 2018,2017,,,34,38,"Comparison of two binary files has many practical applications: the ability to detect programmatic changes between two versions, the ability to find old versions of statically linked libraries to prevent the use of well-known bugs, malware analysis, etc. In this article, a framework for comparison of binary files is presented. Framework uses IdaPro [1] disassembler and Binnavi [2] platform to recover structure of the target program and represent it as a call graph (CG). A program dependence graph (PDG) corresponds to each vertex of the CG. The proposed comparison algorithm consists of two main stages. At the first stage, several heuristics are applied to find the exact matches. Two functions are matched if at least one of the calculated heuristics is the same and unique in both binaries. At the second stage, backward and forward slicing is applied on matched vertices of CG to find further matches. According to empiric results heuristic method is effective and has high matching quality for unchanged or slightly modified functions. As a contradiction, to match heavily modified functions, binary code clone detection is used and it is based on finding maximum common subgraph for pair of PDGs. To achieve high performance on extensive binaries, the whole matching process is parallelized. The framework is tested on the number of real world libraries, such as python, openssh, openssl, libxml2, rsync, php, etc. Results show that in most cases more than 95% functions are truly matched. The tool is scalable due to parallelization of functions matching process and generation of PDGs and CGs.",,978-1-5386-1132-6,10.1109/ISPRAS.2017.00013,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8273295,Binary code comparison;static analysis;program dependence graph,Tools;Computer bugs;Semantics;Cloning;Binary codes;Algorithm design and analysis;Libraries,binary codes;graph theory;invasive software;program debugging;program diagnostics;program slicing,Binnavi platform;call graph;program dependence graph;PDG;forward slicing;backward slicing;maximum common subgraph;real world libraries;functions matching process parallelization;IdaPro disassembler;well-known bugs prevention;matching process;extensive binaries;binary code clone detection;heavily modified functions;slightly modified functions;unchanged modified functions;high matching quality;empiric results heuristic method;matched vertices;calculated heuristics;exact matches;main stages;comparison algorithm;CG;target program;statically linked libraries;old versions;programmatic changes;practical applications;binary files;accurate binary code comparison;scalable framework,,5.0,,22.0,,1 Feb 2018,,,IEEE,IEEE Conferences
Clone Detection on Large Scala Codebases,W. Rahman; Y. Xu; F. Pu; J. Xuan; X. Jia; M. Basios; L. Kanthan; L. Li; F. Wu; B. Xu,"Imperial College London, London, United Kingdom; Wuhan University, Wuhan, China; Wuhan University, Wuhan, China; Wuhan University, Wuhan, China; Wuhan University, Wuhan, China; Turing Intelligence Technology, London, United Kingdom; Turing Intelligence Technology, London, United Kingdom; Turing Intelligence Technology, London, United Kingdom; Turing Intelligence Technology, London, United Kingdom; Nanjing University, Nanjing, China",2020 IEEE 14th International Workshop on Software Clones (IWSC),26 Mar 2020,2020,,,38,44,"Code clones are identical or similar code segments. The wide existence of code clones can increase the cost of maintenance and jeopardise the quality of software. The research community has developed many techniques to detect code clones, however, there is little evidence of how these techniques may perform in industrial use cases. In this paper, we aim to uncover the differences when such techniques are applied in industrial use cases. We conducted large scale experimental research on the performance of two state-of-the-art code clone detection techniques, SourcererCC and AutoenCODE, on both open source projects and an industrial project written in the Scala language. Our results reveal that both algorithms perform differently on the industrial project, with the largest drop in precision being 30.7%, and the largest increase in recall being 32.4%. By manually labelling samples of the industrial project by its developers, we discovered that there are substantially less Type-3 clones in the aforementioned project than that in the open source projects.",2572-6587,978-1-7281-6269-0,10.1109/IWSC50091.2020.9047640,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9047640,Clone Detection;Scala Language,Cloning;Labeling;Detection algorithms;Companies;Deep learning;Java;Syntactics,production engineering computing;public domain software;software maintenance;software quality;source code (software),code clones;industrial use cases;code clone detection;open source projects;industrial project;Type-3 clones;large scala codebases;software quality;SourcererCC;AutoenCODE,,3.0,,33.0,,26 Mar 2020,,,IEEE,IEEE Conferences
Unified Abstract Syntax Tree Representation Learning for Cross-Language Program Classification,K. Wang; M. Yan; H. Zhang; H. Hu,"State Key Lab for Novel Software Technology, Nanjing University, Nanjing, China; School of Big Data & Software Engineering, Chongqing University, Chongqing, China; State Key Lab for Novel Software Technology, Nanjing University, Nanjing, China; School of Big Data & Software Engineering, Chongqing University, Chongqing, China",2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC),22 Jun 2022,2022,,,390,400,"Program classification can be regarded as a high-level abstraction of code, laying a foundation for various tasks related to source code comprehension, and has a very wide range of applications in the field of software engineering, such as code clone detection, code smell classification, defects classification, etc. The cross-language program classification can realize code transfer in different programming languages, and can also promote cross-language code reuse, thereby helping developers to write code quickly and reduce the development time of code transfer. Most of the existing studies focus on the semantic learning of the code, whilst few studies are devoted to cross-language tasks. The main challenge of cross-language program classification is how to extract semantic features of different programming languages. In order to cope with this difficulty, we propose a Unified Abstract Syntax Tree (namely UAST in this paper) neural network. In detail, the core idea of UAST consists of two unified mechanisms. First, UAST learns an AST representation by unifying the AST traversal sequence and graph-like AST structure for capturing semantic code features. Second, we construct a mechanism called unified vocabulary, which can reduce the feature gap between different programming languages, so it can achieve the role of cross-language program classification. Besides, we collect a dataset containing 20,000 files of five programming languages, which can be used as a benchmark dataset for the cross-language program classification task. We have done experiments on two datasets, and the results show that our proposed approach out-performs the state-of-the-art baselines in terms of four evaluation metrics (Precision, Recall, F1-score, and Accuracy).",2643-7171,978-1-4503-9298-3,10.1145/3524610.3527915,National Natural Science Foundation of China(grant numbers:62072227); Research Council of Norway(grant numbers:309494); Natural Science Foundation of Chongqing(grant numbers:cstc2021jcyj-msxmX0538); ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796351,Program Comprehension;Program Classification;Code Representation Learning;Cross-language Program Classification,Representation learning;Computer languages;Vocabulary;Codes;Semantics;Neural networks;Syntactics,data analysis;feature extraction;image classification;learning (artificial intelligence);natural language processing;neural nets;object-oriented programming;pattern classification;program compilers;program diagnostics;software engineering;software libraries;software maintenance;software metrics;tree data structures;trees (mathematics),Unified abstract Syntax Tree representation learning;source code comprehension;code clone detection;code smell classification;code transfer;cross-language code reuse;cross-language tasks;semantic code features;cross-language program classification task,,,,47.0,,22 Jun 2022,,,IEEE,IEEE Conferences
MultiCode: A Unified Code Analysis Framework based on Multi-type and Multi-granularity Semantic Learning,X. Duan; J. Wu; M. Du; T. Luo; M. Yang; Y. Wu,"Intelligent Software Research Center, Institute of Software, Chinese Academy of Sciences University of Chinese Academy of Sciences, Beijing, China; Intelligent Software Research Center, Institute of Software, Chinese Academy of Sciences University of Chinese Academy of Sciences, Beijing, China; Nanjing Institute of Software Technology, Institute of Software, Chinese Academy of Sciences Nanjing University Of Chinese Medicine, Nanjing, China; Intelligent Software Research Center, Institute of Software, Chinese Academy of Sciences, Beijing, China; Beijing ZhongKeWeiLan Technology Co., Ltd., Beijing, China; Intelligent Software Research Center, Institute of Software, Chinese Academy of Sciences, Beijing, China",2021 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW),14 Feb 2022,2021,,,359,364,"Code analysis is one of the common way to ensure software reliability. With the development of machine learning technology, more and more learning-based code analysis methods are proposed. However, most existing methods are aimed at specific code analysis tasks, which leads to the extra effort to implement different models for different tasks in industrial applications. In this paper, we propose MultiCode, a novel unified code analysis framework, which learns code semantic information of different types and granularities to cover the semantic information required by different tasks, so that it can be effectively adapted to multiple tasks with higher accuracy. To prove the effectiveness of MultiCode, we demonstrate and evaluate it on two common tasks: vulnerability detection and code clone detection. Experimental results show that MultiCode achieves F1-scores of 94.6%, 92.5% and 97.1% on SARD-BE, SARD-RME and OJClone datasets, which is significantly higher than the advanced existing methods.",,978-1-6654-2603-9,10.1109/ISSREW53611.2021.00102,National Key R&D Program of China(grant numbers:2018YFB0803600); ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9700202,Machine learning;Graph neural networks;Code analysis,Analytical models;Adaptation models;Codes;Conferences;Semantics;Cloning;Machine learning,learning (artificial intelligence);program diagnostics;security of data;software reliability;source code (software),unified code analysis framework;multigranularity semantic learning;MultiCode;code semantic information;vulnerability detection;code clone detection;multitype semantic learning;SARD-BE dataset;SARD-RME dataset;OJClone dataset;software reliability;machine learning,,,,16.0,IEEE,14 Feb 2022,,,IEEE,IEEE Conferences
A Mocktail of Source Code Representations,D. Vagavolu; K. C. Swarna; S. Chimalakonda,"Dept. of Computer Science & Engineering, Research in Intelligent Software & Human Analytics (RISHA) Lab, Indian Institute of Technology Tirupati, Tirupati, India; Dept. of Computer Science & Engineering, Research in Intelligent Software & Human Analytics (RISHA) Lab, Indian Institute of Technology Tirupati, Tirupati, India; Dept. of Computer Science & Engineering, Research in Intelligent Software & Human Analytics (RISHA) Lab, Indian Institute of Technology Tirupati, Tirupati, India",2021 36th IEEE/ACM International Conference on Automated Software Engineering (ASE),20 Jan 2022,2021,,,1296,1300,"Efficient representation of source code is essential for various software engineering tasks such as code classification and code clone detection. Most recent approaches for representing source code still use AST and do not leverage semantic graphs such as CFG and PDG. One effective technique for representing source code involves extracting paths from the AST and using a learning model to capture program properties. Code2vec is one such path-based approach that uses an attention-based neural network to learn code embeddings which can then be used for various downstream tasks. However, this approach uses only AST and does not leverage CFG and PDG. Even though an integrated graph approach (Code Property Graph) exists for representing source code, it has only been explored in the domain of software security. Moreover, it does not leverage the paths from the individual graphs. Our idea is to extend the path-based approach code2vec to include the semantic graphs CFG and PDG with AST, which is largely unexplored in software engineering. We evaluate our approach on the task of METHODNAMING using a C dataset of 730K methods collected from GitHub. In comparison to code2vec, our approach improves the F1 score by 11% on the full dataset and up to 100% with individual projects. We show that semantic features from the CFG and PDG paths drastically improve the performance of the software engineering tasks. We envision that looking at a mocktail of source code representations for various software engineering tasks can lay the foundation for a new line of research and a re-haul of existing research.",2643-1572,978-1-6654-0337-5,10.1109/ASE51524.2021.9678551,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9678551,Source Code Representation;Abstract Syntax Tree;Control Flow Graph;Program Dependence Graph;Code Embeddings;Method Naming,Adaptation models;Codes;Semantics;Neural networks;Syntactics;Software;Security,graph theory;program diagnostics;public domain software;safety-critical software;security of data;software maintenance;source code (software),code property graph;path-based approach;AST;software engineering tasks;source code representations;code classification;code clone detection;semantic graphs;code embeddings;integrated graph approach;software security;code2vec;semantic graph;METHODNAMING task;C dataset;GitHub;F1 score,,,,34.0,IEEE,20 Jan 2022,,,IEEE,IEEE Conferences
HELoC: Hierarchical Contrastive Learning of Source Code Representation,X. Wang; Q. Wu; H. Zhang; C. Lyu; X. Jiang; Z. Zheng; L. Lyu; S. Hu,"Shandong Normal University, Jinan, China; Shandong Normal University, Jinan, China; The University of Newcastle, NSW, Australia; Shandong Normal University, Jinan, China; Shandong Normal University, Jinan, China; Nanjing University of Science and Technology, Nanjing, China; Shandong Normal University, Jinan, China; Institute of Information Engineering, Chinese Academy of Sciences, Beijing, China",2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC),22 Jun 2022,2022,,,354,365,"Abstract syntax trees (ASTs) play a crucial role in source code representation. However, due to the large number of nodes in an AST and the typically deep AST hierarchy, it is challenging to learn the hierarchical structure of an AST effectively. In this paper, we propose HELoC, a hierarchical contrastive learning model for source code representation. To effectively learn the AST hierarchy, we use contrastive learning to allow the network to predict the AST node level and learn the hierarchical relationships between nodes in a self-supervised manner, which makes the representation vectors of nodes with greater differences in AST levels farther apart in the embedding space. By using such vectors, the structural similarities between code snippets can be measured more precisely. In the learning process, a novel GNN (called Residual Self-attention Graph Neural Network, RSGNN) is designed, which enables HELoC to focus on embedding the local structure of an AST while capturing its overall structure. HELoC is self-supervised and can be applied to many source code related downstream tasks such as code classification, code clone detection, and code clustering after pre-training. Our extensive experiments demonstrate that HELoC outperforms the state-of-the-art source code representation models.",2643-7171,978-1-4503-9298-3,10.1145/3524610.3527896,"National Natural Science Foundation of China(grant numbers:61602286,61976127); ",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796352,Abstract Syntax Tree;Contrastive Learning;Code Representation,Learning systems;Codes;Cloning;Syntactics;Graph neural networks;Task analysis,learning (artificial intelligence);neural nets;pattern clustering;program diagnostics;software engineering;source code (software);source coding;trees (mathematics),HELoC;typically deep AST hierarchy;hierarchical structure;hierarchical contrastive learning model;AST node level;hierarchical relationships;representation vectors;AST levels;code snippets;learning process;code classification;code clone detection;code clustering;state-of-the-art source code representation models,,,,85.0,,22 Jun 2022,,,IEEE,IEEE Conferences
Work in Progress: An Automated Management System for References in Programming Code,M. A. Pangestu; Simon,"University of Newcastle, Callaghan, Australia; University of Newcastle, Callaghan, Australia",2021 IEEE Global Engineering Education Conference (EDUCON),18 Jun 2021,2021,,,1301,1305,"Code reuse is a practice that may both support and hinder the learning process of programming students. To help offset the negative impacts of code reuse, many educators rely on code similarity detection tools as a first step in detecting code plagiarism. An alternative approach, often applied in parallel, is to help deter plagiarism by teaching students the importance of referencing externally sourced code. However, there are no broadly accepted standards for referencing in programming. We have found one standard proposed in the literature, and in this paper we explain the design of a system to help programmers apply that standard. The system we will build is a semi-automated code comment generation system that will rely on a code clone detection approach for detecting similarities between the student's code and the code at a website whose URL the student provides. This will assist the user to create appropriate references, in the form of inline comments, when they reuse code from websites or other sources. This work in progress paper explores the relevant literature, explains the design choices of the system and the plan for its evaluation, and presents a progress report on the work.",2165-9567,978-1-7281-8478-4,10.1109/EDUCON46332.2021.9454112,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9454112,code referencing;code similarity detection;comment generation;academic integrity;programming;computing education,Uniform resource locators;Plagiarism;Conferences;Cloning;Tools;Planning;Engineering education,computer science education;Internet;program diagnostics;software maintenance;source code (software);teaching,automated management system;programming code;code reuse;learning process;programming students;code similarity detection tools;code plagiarism;externally sourced code;broadly accepted standards;code comment generation system;code clone detection approach;student;Website;URL,,,,26.0,,18 Jun 2021,,,IEEE,IEEE Conferences
Unleashing the Power of Compiler Intermediate Representation to Enhance Neural Program Embeddings,Z. Li; P. Ma; H. Wang; S. Wang; Q. Tang; S. Nie; S. Wu,"The Hong Kong University of Science and Technology, Hong Kong SAR; The Hong Kong University of Science and Technology, Hong Kong SAR; The Hong Kong University of Science and Technology, Hong Kong SAR; The Hong Kong University of Science and Technology, Hong Kong SAR; Tencent Security Keen Lab, China; Tencent Security Keen Lab, China; Tencent Security Keen Lab, China",2022 IEEE/ACM 44th International Conference on Software Engineering (ICSE),20 Jun 2022,2022,,,2253,2265,"Neural program embeddings have demonstrated considerable promise in a range of program analysis tasks, including clone identification, program repair, code completion, and program synthesis. However, most existing methods generate neural program embeddings di-rectly from the program source codes, by learning from features such as tokens, abstract syntax trees, and control flow graphs. This paper takes a fresh look at how to improve program embed-dings by leveraging compiler intermediate representation (IR). We first demonstrate simple yet highly effective methods for enhancing embedding quality by training embedding models alongside source code and LLVM IR generated by default optimization levels (e.g., -02). We then introduce IRGEN, a framework based on genetic algorithms (GA), to identify (near-)optimal sequences of optimization flags that can significantly improve embedding quality. We use IRGEN to find optimal sequences of LLVM optimization flags by performing GA on source code datasets. We then extend a popular code embedding model, CodeCMR, by adding a new objective based on triplet loss to enable a joint learning over source code and LLVM IR. We benchmark the quality of embedding using a rep-resentative downstream application, code clone detection. When CodeCMR was trained with source code and LLVM IRs optimized by findings of IRGEN, the embedding quality was significantly im-proved, outperforming the state-of-the-art model, CodeBERT, which was trained only with source code. Our augmented CodeCMR also outperformed CodeCMR trained over source code and IR optimized with default optimization levels. We investigate the properties of optimization flags that increase embedding quality, demonstrate IRGEN's generalization in boosting other embedding models, and establish IRGEN's use in settings with extremely limited training data. Our research and findings demonstrate that a straightforward addition to modern neural code embedding models can provide a highly effective enhancement.",1558-1225,978-1-4503-9221-1,10.1145/3510003.3510217,CCF-Tencent Open Research Fund; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9793906,program embedding;deep learing;compiler technique,Training;Codes;Program processors;Cloning;Training data;Syntactics;Task analysis,embedded systems;genetic algorithms;learning (artificial intelligence);neural nets;program compilers;program diagnostics;program verification,compiler intermediate representation;neural program embeddings;program analysis tasks;program repair;code completion;program synthesis;program source codes;program embed-dings;embedding quality;training embedding models;LLVM IR;default optimization levels;IRGEN;optimal sequences;LLVM optimization flags;source code datasets;popular code embedding model;code clone detection;modern neural code embedding models,,,,106.0,,20 Jun 2022,,,IEEE,IEEE Conferences
[Research Paper] On the Use of Machine Learning Techniques Towards the Design of Cloud Based Automatic Code Clone Validation Tools,G. Mostaeen; J. Svajlenko; B. Roy; C. K. Roy; K. A. Schneider,"Department of Computer Science, University of Saskatchewan, Saskatoon, Canada; Department of Computer Science, University of Saskatchewan, Saskatoon, Canada; Department of Computer Science, University of Saskatchewan, Saskatoon, Canada; Department of Computer Science, University of Saskatchewan, Saskatoon, Canada; Department of Computer Science, University of Saskatchewan, Saskatoon, Canada",2018 IEEE 18th International Working Conference on Source Code Analysis and Manipulation (SCAM),11 Nov 2018,2018,,,155,164,"A code clone is a pair of code fragments, within or between software systems that are similar. Since code clones often negatively impact the maintainability of a software system, a great many numbers of code clone detection techniques and tools have been proposed and studied over the last decade. To detect all possible similar source code patterns in general, the clone detection tools work on syntax level (such as texts, tokens, AST and so on) while lacking user-specific preferences. This often means the reported clones must be manually validated prior to any analysis in order to filter out the true positive clones from task or user-specific considerations. This manual clone validation effort is very time-consuming and often error-prone, in particular for large-scale clone detection. In this paper, we propose a machine learning based approach for automating the validation process. In an experiment with clones detected by several clone detectors in several different software systems, we found our approach has an accuracy of up to 87.4% when compared against the manual validation by multiple expert judges. The proposed method shows promising results in several comparative studies with the existing related approaches for automatic code clone validation. We also present our experimental results in terms of different code clone detection tools, machine learning algorithms and open source software systems.",2470-6892,978-1-5386-8290-6,10.1109/SCAM.2018.00025,,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8530729,"Code clones, validation, Machine Learning, Clone Management",Cloning;Tools;Software systems;Feature extraction;Machine learning;Manuals;Syntactics,cloud computing;learning (artificial intelligence);object-oriented methods;object-oriented programming;program verification;public domain software;software maintenance;software tools,manual validation;open source software systems;machine learning techniques;cloud based automatic code clone validation;user-specific preferences;source code patterns;syntax level;time-consuming;multiple expert judges,,4.0,,53.0,,11 Nov 2018,,,IEEE,IEEE Conferences
An Automatic Advisor for Refactoring Software Clones Based on Machine Learning,A. M. Sheneamer,"Department of Computer Science, Faculty of Computer Science and Information Technology, Jazan University, Jazan, Saudi Arabia",IEEE Access,16 Jul 2020,2020,8.0,,124978,124988,"To assist developers refactored code and to enable improvements to software quality when numbers of clones are found in software programs, we require an approach to advise developers on what a clone needs to refactor and what type of refactoring is needed. This paper suggests a unique learning method that automatically extracts features from the detected code clones and trains models to advise developers on what type needs to be refactored. Our approach differs from others, which specifies types of refactored clones as classes and creates a model for detecting the types of refactored clones and the clones which are anonymous. We introduce a new method by which to convert refactoring clone type outliers into Unknown clone set to improve classification results. We present an extensive comparative study and an evaluation of the efficacy of our suggested idea by using state-of-the-art classification models.",2169-3536,,10.1109/ACCESS.2020.3006178,Jazan University; ,https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9130671,Refactoring clone;machine learning;outlier detection;classification;AST and PDG features,Cloning;Tools;Feature extraction;Software;Machine learning;Computer bugs;Object oriented modeling,feature extraction;learning (artificial intelligence);pattern classification;software maintenance;software quality,machine learning;software quality;software programs;code clone detection;clone type outliers;automatic advisor;software clone refactoring;feature extraction,,4.0,,31.0,CCBY,1 Jul 2020,,,IEEE,IEEE Journals
Bridging Pre-trained Models and Downstream Tasks for Source Code Understanding,D. Wang; Z. Jia; S. Li; Y. Yu; Y. Xiong; W. Dong; X. Liao,"National University of Defense Technology, China; National University of Defense Technology, China; National University of Defense Technology, China; National University of Defense Technology, China; Fudan University, Shanghai, China; National University of Defense Technology, China; National University of Defense Technology, China",2022 IEEE/ACM 44th International Conference on Software Engineering (ICSE),20 Jun 2022,2022,,,287,298,"With the great success of pre-trained models, the pretrain-then-fine tune paradigm has been widely adopted on downstream tasks for source code understanding. However, compared to costly training a large-scale model from scratch, how to effectively adapt pre-trained models to a new task has not been fully explored. In this paper, we propose an approach to bridge pre-trained models and code-related tasks. We exploit semantic-preserving transformation to enrich downstream data diversity, and help pre-trained models learn semantic features invariant to these semantically equivalent transformations. Further, we introduce curriculum learning to or-ganize the transformed data in an easy-to-hard manner to fine-tune existing pre-trained models. We apply our approach to a range of pre-trained models, and they significantly outperform the state-of-the-art models on tasks for source code understanding, such as algorithm classification, code clone detection, and code search. Our experiments even show that without heavy pre-training on code data, natural language pre-trained model RoBERTa fine-tuned with our lightweight approach could outperform or rival existing code pre-trained models fine-tuned on the above tasks, such as CodeBERT and GraphCodeBERT. This finding suggests that there is still much room for improvement in code pre-trained models.",1558-1225,978-1-4503-9221-1,10.1145/3510003.3510062,"National Natural Science Foundation of China(grant numbers:61690203,61872373,62032019,U1936213); ",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9793959,fine-tuning;data augmentation;curriculum learning;test-time aug-mentation,Training;Adaptation models;Codes;Natural languages;Semantics;Cloning;Data models,learning (artificial intelligence);natural language processing;software maintenance,source code understanding;downstream tasks;existing pre-trained models;heavy pre-training;natural language pre-trained model RoBERTa fine-tuned;existing code pre-trained models;bridging pre-trained models,,,,58.0,,20 Jun 2022,,,IEEE,IEEE Conferences
Zero-Shot Program Representation Learning,N. Cui; Y. Jiang; X. Gu; B. Shen,"School of Software, Shanghai Jiao Tong University, Shanghai, China; School of Software, Shanghai Jiao Tong University, Shanghai, China; School of Software, Shanghai Jiao Tong University, Shanghai, China; School of Software, Shanghai Jiao Tong University, Shanghai, China",2022 IEEE/ACM 30th International Conference on Program Comprehension (ICPC),22 Jun 2022,2022,,,60,70,"Learning program representations has been the core prerequisite of code intelligence tasks (e.g., code search and code clone detection). The state-of-the-art pre-trained models such as CodeBERT require the availability of large-scale code corpora. However, gathering training samples can be costly and infeasible for domain-specific languages such as Solidity for smart contracts. In this paper, we propose Zecoler, a zero-shot learning approach for code representations. Zecoler is built upon a pre-trained programming language model. In order to elicit knowledge from the pre-trained models efficiently, Zecoler casts the downstream tasks to the same form of pre-training tasks by inserting trainable prompts into the original input. Then, it employs the prompt learning technique to optimize the pre-trained model by merely adjusting the original input. This enables the representation model to efficiently fit the scarce task-specific data while reusing pre-trained knowledge. We evaluate Zecoler in three code intelligence tasks in two programming languages that have no training samples, namely, Solidity and Go, with model trained in corpora of common languages such as Java. Experimental results show that our approach significantly outperforms baseline models in both zero-shot and few-shot settings.",2643-7171,978-1-4503-9298-3,10.1145/3524610.3527888,"National Natural Science Foundation of China(grant numbers:62032004,62102244); ",https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9796313,Learning Program Representations;Zero-Shot Learning;Prompt Learning;Code Intelligence,Representation learning;Training;Computer languages;Solid modeling;Codes;Smart contracts;Cloning,high level languages;learning (artificial intelligence),zero-shot program representation learning;code intelligence tasks;domain-specific languages;Zecoler;code representations;pre-trained programming language model;prompt learning technique;smart contracts,,,,44.0,,22 Jun 2022,,,IEEE,IEEE Conferences
