Key,Item Type,Publication Year,Author,Title,Publication Title,ISBN,ISSN,DOI,Url,Abstract Note,Date,Date Added,Date Modified,Access Date,Pages,Num Pages,Issue,Volume,Number Of Volumes,Journal Abbreviation,Short Title,Series,Series Number,Series Text,Series Title,Publisher,Place,Language,Rights,Type,Archive,Archive Location,Library Catalog,Call Number,Extra,Notes,File Attachments,Link Attachments,Manual Tags,Automatic Tags,Editor,Series Editor,Translator,Contributor,Attorney Agent,Book Author,Cast Member,Commenter,Composer,Cosponsor,Counsel,Interviewer,Producer,Recipient,Reviewed Author,Scriptwriter,Words By,Guest,Number,Edition,Running Time,Scale,Medium,Artwork Size,Filing Date,Application Number,Assignee,Issuing Authority,Country,Meeting Name,Conference Name,Court,References,Reporter,Legal Status,Priority Numbers,Programming Language,Version,System,Code,Code Number,Section,Session,Committee,History,Legislative Body
GYBS27KX,journalArticle,2021,"Hemel, Armijn; Kalleberg, Karl Trygve; Vermaas, Rob; Dolstra, Eelco",Finding Software License Violations Through Binary Code Clone Detection - A Retrospective,SIGSOFT Softw. Eng. Notes,,0163-5948,10.1145/3468744.3468752,https://doi.org/10.1145/3468744.3468752,"Ten years ago, we published the article Finding software license violations through binary code clone detection at the MSR 2011 conference. Our paper was motivated by the tendency of em- bedded hardware vendors to only release binary blobs of their rmware, often violating the licensing terms of open-source soft- ware present inside those blobs. The techniques presented in our paper were designed to accurately identify open-source code hid- den inside binary blobs. Here, we give our perspectives on the impact of our work, both industrially and academically, and re- visit the original problem statement to see what has happened in the eld of open-source compliance in the intervening decade.",2021-07,2022-10-16 23:12:58,2022-10-16 23:12:58,,24–25,,3.0,46.0,,,,,,,,,,,,,,,,,"Place: New York, NY, USA Publisher: Association for Computing Machinery",,,,code clone detection; binary analysis; repository mining; rmware,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
C87RHVXD,conferencePaper,2017,"Dang, Yingnong; Zhang, Dongmei; Ge, Song; Huang, Ray; Chu, Chengyun; Xie, Tao",Transferring Code-Clone Detection and Analysis to Practice,Proceedings of the 39th International Conference on Software Engineering: Software Engineering in Practice Track,978-1-5386-2717-4,,10.1109/ICSE-SEIP.2017.6,https://doi.org/10.1109/ICSE-SEIP.2017.6,"During software development, code clones are commonly produced, in the form of a number of the same or similar code fragments spreading within one or many large code bases. Numerous research projects have been carried out on empirical studies or tool support for detecting or analyzing code clones. However, in practice, few such research projects have resulted in substantial industry adoption. In this paper, we report our experiences of transferring XIAO, a code-clone detection and analysis approach and its supporting tool, to broad industrial practices: (1) shipped in Visual Studio 2012, a widely used industrial IDE; (2) deployed and intensively used at the Microsoft Security Response Center. According to our experiences, technology transfer is a rather complicated journey that needs significant efforts from both the technical aspect and social aspect. From the technical aspect, significant efforts are needed to adapt a research prototype to a product-quality tool that addresses the needs of real scenarios, to be integrated into a mainstream product or development process. From the social aspect, there are strong needs to interact with practitioners to identify killer scenarios in industrial settings, figure out the gap between a research prototype and a tool fitting the needs of real scenarios, to understand the requirements of releasing with a mainstream product, being integrated into a development process, understanding their release cadence, etc.",2017,2022-10-16 23:12:58,2022-10-16 23:12:58,,53–62,,,,,,,ICSE-SEIP '17,,,,IEEE Press,,,,,,,,,"event-place: Buenos Aires, Argentina",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
9NGN7EB5,conferencePaper,2018,"Xue, Hongfa; Venkataramani, Guru; Lan, Tian",Clone-Hunter: Accelerated Bound Checks Elimination via Binary Code Clone Detection,Proceedings of the 2nd ACM SIGPLAN International Workshop on Machine Learning and Programming Languages,978-1-4503-5834-7,,10.1145/3211346.3211347,https://doi.org/10.1145/3211346.3211347,"Unsafe pointer usage and illegitimate memory accesses are prevalent bugs in software. To ensure memory safety, conditions for array bound checks are inserted into the code to detect out-of-bound memory accesses. Unfortunately, these bound checks contribute to high runtime overheads, and therefore, redundant array bound checks should be removed to improve application performance. In this paper, we propose Clone-Hunter, a practical and scalable framework for redundant bound check elimination in binary executables. Clone-Hunter first uses binary code clone detection, and then employs bound safety verification mechanism (using binary symbolic execution) to ensure sound removal of redundant bound checks. Our results show the Clone-Hunter can swiftly identify redundant bound checks about 90× faster than pure binary symbolic execution, while ensuring zero false positives.",2018,2022-10-16 23:12:58,2022-10-16 23:12:58,,11–19,,,,,,,MAPL 2018,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Philadelphia, PA, USA",,,,Array bound checks; Binary analysis; Machine learning; Memory safety,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
K2XVWTN7,journalArticle,2020,"Wang, Wenhan; Li, Ge; Shen, Sijie; Xia, Xin; Jin, Zhi",Modular Tree Network for Source Code Representation Learning,ACM Trans. Softw. Eng. Methodol.,,1049-331X,10.1145/3409331,https://doi.org/10.1145/3409331,"Learning representation for source code is a foundation of many program analysis tasks. In recent years, neural networks have already shown success in this area, but most existing models did not make full use of the unique structural information of programs. Although abstract syntax tree (AST)-based neural models can handle the tree structure in the source code, they cannot capture the richness of different types of substructure in programs. In this article, we propose a modular tree network that dynamically composes different neural network units into tree structures based on the input AST. Different from previous tree-structural neural network models, a modular tree network can capture the semantic differences between types of AST substructures. We evaluate our model on two tasks: program classification and code clone detection. Our model achieves the best performance compared with state-of-the-art approaches in both tasks, showing the advantage of leveraging more elaborate structure information of the source code.",2020-09,2022-10-16 23:12:58,2022-10-16 23:12:58,,,,4.0,29.0,,,,,,,,,,,,,,,,,"Place: New York, NY, USA Publisher: Association for Computing Machinery",,,,code clone detection; neural networks; Deep learning; program classification,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
W9D7NNDH,conferencePaper,2019,"Zhang, Jian; Wang, Xu; Zhang, Hongyu; Sun, Hailong; Wang, Kaixuan; Liu, Xudong",A Novel Neural Source Code Representation Based on Abstract Syntax Tree,Proceedings of the 41st International Conference on Software Engineering,,,10.1109/ICSE.2019.00086,https://doi.org/10.1109/ICSE.2019.00086,"Exploiting machine learning techniques for analyzing programs has attracted much attention. One key problem is how to represent code fragments well for follow-up analysis. Traditional information retrieval based methods often treat programs as natural language texts, which could miss important semantic information of source code. Recently, state-of-the-art studies demonstrate that abstract syntax tree (AST) based neural models can better represent source code. However, the sizes of ASTs are usually large and the existing models are prone to the long-term dependency problem. In this paper, we propose a novel AST-based Neural Network (ASTNN) for source code representation. Unlike existing models that work on entire ASTs, ASTNN splits each large AST into a sequence of small statement trees, and encodes the statement trees to vectors by capturing the lexical and syntactical knowledge of statements. Based on the sequence of statement vectors, a bidirectional RNN model is used to leverage the naturalness of statements and finally produce the vector representation of a code fragment. We have applied our neural network based source code representation method to two common program comprehension tasks: source code classification and code clone detection. Experimental results on the two tasks indicate that our model is superior to state-of-the-art approaches.",2019,2022-10-16 23:12:58,2022-10-16 23:12:58,,783–794,,,,,,,ICSE '19,,,,IEEE Press,,,,,,,,,"event-place: Montreal, Quebec, Canada",,,,code clone detection; abstract syntax tree; code classification; neural network; source code representation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
E6J2YFYA,conferencePaper,2020,"Rost, Wolf",Mining of DSLs and Generator Templates from Reference Applications,Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings,978-1-4503-8135-2,,10.1145/3417990.3419492,https://doi.org/10.1145/3417990.3419492,"Domain-Specific Languages (DSLs) found application in different domains. The development of Model-Driven Development (MDD) components is facilitated by a wealth of frameworks like EMF, Xtext, and Xtend. However, the development of the necessary IDE components still can take up to several weeks or even months until it can be used in a production environment. The first step during the development of such an MDD infrastructure is to analyse a set of reference applications to deduce the DSL used by the domain experts and the templates used in the generator. The analysis requires technical expertise and is usually performed by MDD infrastructure developers, who have to adhere to a close communication with domain experts and are exposed to high cognitive load and time-consuming tasks.The objective of this PhD project is to reduce the initial effort during the creation of new MDD infrastructure facilities for either a new domain or newly discovered platforms within a known domain. This should be made possible by the (semi-)automatic analysis of multiple codebases using Code Clone Detection (CCD) tools in a defined process flow. Code clones represent schematically redundant and generic code fragments which were found in the provided codebase. In the process, the key steps include (i) choosing appropriate reference applications (ii) distinguishing the codebase by clustering the files, (iii) reviewing the quality of the clusters, (iv) analysing the cluster by tailored CCD, and (v) transforming of the code clones, depending on the code clone type, to extract a DSL and the corresponding generator templates.",2020,2022-10-16 23:12:58,2022-10-16 23:12:58,,,,,,,,,MODELS '20,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Virtual Event, Canada",,,,code clone detection; clustering and classification; information extraction; MDD component creation; model-driven software engineering,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EBWCAAT2,conferencePaper,2020,"Wu, Xiongfei; Qin, Liangyu; Yu, Bing; Xie, Xiaofei; Ma, Lei; Xue, Yinxing; Liu, Yang; Zhao, Jianjun",How Are Deep Learning Models Similar? An Empirical Study on Clone Analysis of Deep Learning Software,Proceedings of the 28th International Conference on Program Comprehension,978-1-4503-7958-8,,10.1145/3387904.3389254,https://doi.org/10.1145/3387904.3389254,"Deep learning (DL) has been successfully applied to many cutting-edge applications, e.g., image processing, speech recognition, and natural language processing. As more and more DL software is made open-sourced, publicly available, and organized in model repositories and stores (Model Zoo, ModelDepot), there comes a need to understand the relationships of these DL models regarding their maintenance and evolution tasks. Although clone analysis has been extensively studied for traditional software, up to the present, clone analysis has not been investigated for DL software. Since DL software adopts the data-driven development paradigm, it is still not clear whether and to what extent the clone analysis techniques of traditional software could be adapted to DL software.In this paper, we initiate the first step on the clone analysis of DL software at three different levels, i.e., source code level, model structural level, and input/output (I/0)-semantic level, which would be a key in DL software management, maintenance and evolution. We intend to investigate the similarity between these DL models from clone analysis perspective. Several tools and metrics are selected to conduct clone analysis of DL software at three different levels. Our study on two popular datasets (i.e., MNIST and CIFAR-10) and eight DL models of five architectural families (i.e., LeNet, ResNet, DenseNet, AlexNet, and VGG) shows that: 1). the three levels of similarity analysis are generally adequate to find clones between DL models ranging from structural to semantic; 2). different measures for clone analysis used at each level yield similar results; 3) clone analysis of one single level may not render a complete picture of the similarity of DL models. Our findings open up several research opportunities worth further exploration towards better understanding and more effective clone analysis of DL software.",2020,2022-10-16 23:12:58,2022-10-16 23:12:58,,172–183,,,,,,,ICPC '20,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Seoul, Republic of Korea",,,,deep learning; Code clone detection; model similarity,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SEN9X5PX,conferencePaper,2017,"Krüger, Jacob; Nell, Louis; Fenske, Wolfram; Saake, Gunter; Leich, Thomas",Finding Lost Features in Cloned Systems,Proceedings of the 21st International Systems and Software Product Line Conference - Volume B,978-1-4503-5119-5,,10.1145/3109729.3109736,https://doi.org/10.1145/3109729.3109736,"Copying and adapting a system, also known as clone-and-own, is a common reuse approach that requires little initial effort. However, the drawbacks of clones are increasing maintenance costs as bug fixes and updates must be propagated. To reduce these costs, migrating cloned legacy systems towards a software product line promises to enable systematic reuse and customization. For both, managing and migrating cloned systems, it remains a challenge to identify and map features in the systems. In this paper, we i) propose a semi-automatic process to identify and map features between legacy systems, ii) suggest a corresponding visualization approach, and iii) assess our process on a case study. The results indicate that our process is suitable to identify features and present commonalities and variability in cloned systems. Our process can be used to enable traceability, prepare refactorings, and extract software product lines.",2017,2022-10-16 23:12:58,2022-10-16 23:12:58,,65–72,,,,,,,SPLC '17,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Sevilla, Spain",,,,code clone detection; reverse engineering; extractive approach; feature location; legacy system; Software product line,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
6HQAI9X5,conferencePaper,2017,"McAfee, Patrick; Mkaouer, Mohamed Wiem; Krutz, Daniel E.",CATE: Concolic Android Testing Using Java Pathfinder for Android Applications,Proceedings of the 4th International Conference on Mobile Software Engineering and Systems,978-1-5386-2669-6,,10.1109/MOBILESoft.2017.35,https://doi.org/10.1109/MOBILESoft.2017.35,"Like all software systems, Android applications are not immune to bugs, security vulnerabilities, and a wide range of other runtime errors. Concolic analysis, a hybrid software verification technique which performs symbolic execution along with a concrete execution path, has been used for a variety of purposes including software testing, code clone detection, and security-related activities. We created a new publicly available concolic analysis tool for analyzing Android applications: Concolic Android TEster (CATE). Building on Java Path Finder (JPF-SPF), this tool performs concolic analysis on a raw Android application file (or source code) and provides output in a useful and easy to understand format.",2017,2022-10-16 23:12:58,2022-10-16 23:12:58,,213–214,,,,,,,MOBILESoft '17,,,,IEEE Press,,,,,,,,,"event-place: Buenos Aires, Argentina",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CK49M7NK,journalArticle,2022,"Lin, Zehao; Li, Guodun; Zhang, Jingfeng; Deng, Yue; Zeng, Xiangji; Zhang, Yin; Wan, Yao",XCode: Towards Cross-Language Code Representation with Large-Scale Pre-Training,ACM Trans. Softw. Eng. Methodol.,,1049-331X,10.1145/3506696,https://doi.org/10.1145/3506696,"Source code representation learning is the basis of applying artificial intelligence to many software engineering tasks such as code clone detection, algorithm classification, and code summarization. Recently, many works have tried to improve the performance of source code representation from various perspectives, e.g., introducing the structural information of programs into latent representation. However, when dealing with rapidly expanded unlabeled cross-language source code datasets from the Internet, there are still two issues. Firstly, deep learning models for many code-specific tasks still suffer from the lack of high-quality labels. Secondly, the structural differences among programming languages make it more difficult to process multiple languages in a single neural architecture.To address these issues, in this article, we propose a novel Cross-language Code representation with a large-scale pre-training (XCode) method. Concretely, we propose to use several abstract syntax trees and ELMo-enhanced variational autoencoders to obtain multiple pre-trained source code language models trained on about 1.5 million code snippets. To fully utilize the knowledge across programming languages, we further propose a Shared Encoder-Decoder (SED) architecture which uses the multi-teacher single-student method to transfer knowledge from the aforementioned pre-trained models to the distilled SED. The pre-trained models and SED will cooperate to better represent the source code. For evaluation, we examine our approach on three typical downstream cross-language tasks, i.e., source code translation, code clone detection, and code-to-code search, on a real-world dataset composed of programming exercises with multiple solutions. Experimental results demonstrate the effectiveness of our proposed approach on cross-language code representations. Meanwhile, our approach performs significantly better than several code representation baselines on different downstream tasks in terms of multiple automatic evaluation metrics.",2022-04,2022-10-16 23:12:58,2022-10-16 23:12:58,,,,3.0,31.0,,,,,,,,,,,,,,,,,"Place: New York, NY, USA Publisher: Association for Computing Machinery",,,,neural networks; code representation; Deep learning; cross-language; pre-training,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
3QF4IWJX,conferencePaper,2019,"Tokumoto, Susumu; Takayama, Kuniharu",PHANTA: Diversified Test Code Quality Measurement for Modern Software Development,Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering,978-1-72812-508-4,,10.1109/ASE.2019.00138,https://doi.org/10.1109/ASE.2019.00138,"Test code is becoming more essential to the modern software development process. However, practitioners often pay inadequate attention to key aspects of test code quality, such as bug detectability, maintainability and speed. Existing tools also typically report a single test code quality measure, such as code coverage, rather than a diversified set of metrics. To measure and visualize quality of test code in a comprehensive fashion, we developed an integrated test code analysis tool called Phanta. In this show case, we posit that the enhancement of test code quality is key to modernizing software development, and show how Phanta's techniques measure the quality using mutation analysis, test code clone detection, and so on. Further, we present an industrial case study where Phanta was applied to analyze test code in a real Fujitsu project, and share lessons learned from the case study.",2019,2022-10-16 23:12:59,2022-10-16 23:12:59,,1206–1207,,,,,,,ASE '19,,,,IEEE Press,,,,,,,,,"event-place: San Diego, California",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DYIJVFYN,conferencePaper,2019,"Babur, Önder; Stephan, Matthew",MoCoP: Towards a Model Clone Portal,Proceedings of the 11th International Workshop on Modelling in Software Engineerings,,,10.1109/MiSE.2019.00019,https://doi.org/10.1109/MiSE.2019.00019,"Widespread and mature practice of model-driven engineering is leading to a growing number of modeling artifacts and challenges in their management. Model clone detection (MCD) is an important approach for managing and maintaining modeling artifacts. While its counterpart in traditional source code development, code clone detection, is enjoying popularity and more than two decades of development, MCD is still in its infancy in terms of research and tooling. We aim to develop a portal for model clone detection, MoCoP, as a central hub to mitigate adoption barriers and foster MCD research. In this short paper, we present our vision for MoCoP and its features and goals. We discuss MoCoP's key components that we plan on realizing in the short term including public tooling, curated data sets, and a body of MCD knowledge. Our longer term goals include a dedicated service-oriented infrastructure, contests, and forums. We believe MoCoP will strengthen MCD research, tooling, and the community, which in turn will lead to better quality, maintenance, and scalability for model-driven engineering practices.",2019,2022-10-16 23:12:59,2022-10-16 23:12:59,,78–81,,,,,,,MiSE '19,,,,IEEE Press,,,,,,,,,"event-place: Montreal, Quebec, Canada",,,,software maintenance; model analytics; model clone detection; model management; model repositories; model-driven engineering,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
HUY2BC26,conferencePaper,2019,"Mostaeen, Golam; Svajlenko, Jeffrey; Roy, Banani; Roy, Chanchal K.; Schneider, Kevin A.",CloneCognition: Machine Learning Based Code Clone Validation Tool,Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering,978-1-4503-5572-8,,10.1145/3338906.3341182,https://doi.org/10.1145/3338906.3341182,"A code clone is a pair of similar code fragments, within or between software systems. To detect each possible clone pair from a software system while handling the complex code structures, the clone detection tools undergo a lot of generalization of the original source codes. The generalization often results in returning code fragments that are only coincidentally similar and not considered clones by users, and hence requires manual validation of the reported possible clones by users which is often both time-consuming and challenging. In this paper, we propose a machine learning based tool 'CloneCognition' (Open Source Codes: https://github.com/pseudoPixels/CloneCognition ; Video Demonstration: https://www.youtube.com/watch?v=KYQjmdr8rsw) to automate the laborious manual validation process. The tool runs on top of any code clone detection tools to facilitate the clone validation process. The tool shows promising clone classification performance with an accuracy of up to 87.4%. The tool also exhibits significant improvement in the results when compared with state-of-the-art techniques for code clone validation.",2019,2022-10-16 23:12:59,2022-10-16 23:12:59,,1105–1109,,,,,,,ESEC/FSE 2019,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Tallinn, Estonia",,,,Machine Learning; Artificial Neural Network; Clone Management; Code Clones; Validation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ZGQYYZMG,conferencePaper,2022,"Wang, Deze; Jia, Zhouyang; Li, Shanshan; Yu, Yue; Xiong, Yun; Dong, Wei; Liao, Xiangke",Bridging Pre-Trained Models and Downstream Tasks for Source Code Understanding,Proceedings of the 44th International Conference on Software Engineering,978-1-4503-9221-1,,10.1145/3510003.3510062,https://doi.org/10.1145/3510003.3510062,"With the great success of pre-trained models, the pretrain-then-finetune paradigm has been widely adopted on downstream tasks for source code understanding. However, compared to costly training a large-scale model from scratch, how to effectively adapt pre-trained models to a new task has not been fully explored. In this paper, we propose an approach to bridge pre-trained models and code-related tasks. We exploit semantic-preserving transformation to enrich downstream data diversity, and help pre-trained models learn semantic features invariant to these semantically equivalent transformations. Further, we introduce curriculum learning to organize the transformed data in an easy-to-hard manner to fine-tune existing pre-trained models.We apply our approach to a range of pre-trained models, and they significantly outperform the state-of-the-art models on tasks for source code understanding, such as algorithm classification, code clone detection, and code search. Our experiments even show that without heavy pre-training on code data, natural language pre-trained model RoBERTa fine-tuned with our lightweight approach could outperform or rival existing code pre-trained models fine-tuned on the above tasks, such as CodeBERT and GraphCodeBERT. This finding suggests that there is still much room for improvement in code pre-trained models.",2022,2022-10-16 23:12:59,2022-10-16 23:12:59,,287–298,,,,,,,ICSE '22,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Pittsburgh, Pennsylvania",,,,curriculum learning; data augmentation; fine-tuning; test-time augmentation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
RN7MZVA6,journalArticle,2022,"Zhang, Huangzhao; Fu, Zhiyi; Li, Ge; Ma, Lei; Zhao, Zhehao; Yang, Hua’an; Sun, Yizhe; Liu, Yang; Jin, Zhi","Towards Robustness of Deep Program Processing Models—Detection, Estimation, and Enhancement",ACM Trans. Softw. Eng. Methodol.,,1049-331X,10.1145/3511887,https://doi.org/10.1145/3511887,"Deep learning (DL) has recently been widely applied to diverse source code processing tasks in the software engineering (SE) community, which achieves competitive performance (e.g., accuracy). However, the robustness, which requires the model to produce consistent decisions given minorly perturbed code inputs, still lacks systematic investigation as an important quality indicator. This article initiates an early step and proposes a framework CARROT for robustness detection, measurement, and enhancement of DL models for source code processing. We first propose an optimization-based attack technique CARROTA to generate valid adversarial source code examples effectively and efficiently. Based on this, we define the robustness metrics and propose robustness measurement toolkit CARROTM, which employs the worst-case performance approximation under the allowable perturbations. We further propose to improve the robustness of the DL models by adversarial training (CARROTT) with our proposed attack techniques. Our in-depth evaluations on three source code processing tasks (i.e., functionality classification, code clone detection, defect prediction) containing more than 3 million lines of code and the classic or SOTA DL models, including GRU, LSTM, ASTNN, LSCNN, TBCNN, CodeBERT, and CDLH, demonstrate the usefulness of our techniques for ❶ effective and efficient adversarial example detection, ❷ tight robustness estimation, and ❸ effective robustness enhancement.",2022-04,2022-10-16 23:12:59,2022-10-16 23:12:59,,,,3.0,31.0,,,,,,,,,,,,,,,,,"Place: New York, NY, USA Publisher: Association for Computing Machinery",,,,adversarial attack; big code; robustness enhancement; Source code processing,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
HRHDMY6V,conferencePaper,2021,"Vagavolu, Dheeraj; Swarna, Karthik Chandra; Chimalakonda, Sridhar",A Mocktail of Source Code Representations,Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering,978-1-66540-337-5,,10.1109/ASE51524.2021.9678551,https://doi.org/10.1109/ASE51524.2021.9678551,"Efficient representation of source code is essential for various software engineering tasks such as code classification and code clone detection. Most recent approaches for representing source code still use AST and do not leverage semantic graphs such as CFG and PDG. One effective technique for representing source code involves extracting paths from the AST and using a learning model to capture program properties. Code2vec is one such path-based approach that uses an attention-based neural network to learn code embeddings which can then be used for various downstream tasks. However, this approach uses only AST and does not leverage CFG and PDG. Even though an integrated graph approach (Code Property Graph) exists for representing source code, it has only been explored in the domain of software security. Moreover, it does not leverage the paths from the individual graphs. Our idea is to extend the path-based approach code2vec to include the semantic graphs CFG and PDG with AST, which is largely unexplored in software engineering. We evaluate our approach on the task of MethodNaming using a C dataset of 730K methods collected from GitHub. In comparison to code2vec, our approach improves the F1 score by 11% on the full dataset and up to 100% with individual projects. We show that semantic features from the CFG and PDG paths drastically improve the performance of the software engineering tasks. We envision that looking at a mocktail of source code representations for various software engineering tasks can lay the foundation for a new line of research and a re-haul of existing research.",2021,2022-10-16 23:12:59,2022-10-16 23:12:59,,1296–1300,,,,,,,ASE '21,,,,IEEE Press,,,,,,,,,"event-place: Melbourne, Australia",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
58E6PLL6,conferencePaper,2020,"Gholamian, Sina; Ward, Paul A. S.",Logging Statements' Prediction Based on Source Code Clones,Proceedings of the 35th Annual ACM Symposium on Applied Computing,978-1-4503-6866-7,,10.1145/3341105.3373845,https://doi.org/10.1145/3341105.3373845,"Log files are widely used to record runtime information of software systems, such as the time-stamp of an event, the unique ID of the source of the log, and a part of the state of task execution. The rich information of logs enables system operators to monitor the runtime behaviors of their systems and further track down system problems in production settings. Although logs are useful, there exists a trade-off between their benefit and cost, and it is a crucial problem to optimize the location and content of log messages in the source code, i.e., ""where and what to log?""Prior research has analyzed logging statements in the source code and proposed ways to predict and suggest the location of log statements in order to partially automate log statement addition to the source code. However, there are gaps and unsolved problems in the literature to fully automate the logging process. Thus, in this research, we perform an experimental study on open-source Java projects and apply code-clone detection methods for log statements' prediction. Our work demonstrates the feasibility of logging automation by predicting the location of a log point in a code snippet based on the existence of a logging statement in its corresponding code clone pair. We propose a Log-Aware Code-Clone Detector (LACC) which achieves a higher accuracy of log prediction when compared to state-of-the-art general-purpose clone detectors. Our analysis shows that 98% of clone snippets match in their logging behavior, and LACC can predict the location of logging statements by the accuracy of 90+% for Apache Java projects.",2020,2022-10-16 23:12:59,2022-10-16 23:12:59,,82–91,,,,,,,SAC '20,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Brno, Czech Republic",,,,software engineering; code clones; automation; logging statement; source code,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
R4YAN5AR,conferencePaper,2022,"Schulze, Sandro; Krüger, Jacob; Wünsche, Johannes",Towards Developer Support for Merging Forked Test Cases,Proceedings of the 26th ACM International Systems and Software Product Line Conference - Volume A,978-1-4503-9443-7,,10.1145/3546932.3547002,https://doi.org/10.1145/3546932.3547002,"Developers rely on branching and forking mechanisms of modern versioning systems to evolve and maintain their software systems. As a result, systems often exist in the form of various short-living or even long-living (i.e., clone &amp; own development) variants. Such variants may have to be merged with the main system or other variants, for instance, to propagate features or bug fixes. Within such merging processes, test cases are highly interesting, since they allow to improve the test coverage and hopefully the reliability of the system (e.g., by merging missing tests and bug fixes in test code). However, as all source code, test cases may evolve independently between two or more variants, which makes it non-trivial to decide what changes of the test cases are relevant for the merging. For instance, some test cases in one variant may be irrelevant in another variant (e.g., because the feature shall not be propagated) or may subsume existing test cases. In this paper, we propose a technique that allows for a fine-grained comparison of test cases to support developers in deciding whether and how to merge these. Precisely, inspired by code-clone detection, we use abstract syntax trees to decide on the relations between test cases of different variants. We evaluate the applicability of our technique qualitatively on five open-source systems written in Java (e.g., JUnit 5, Guava). Our insights into the merge potential of 50 pull requests with test cases from these systems indicate that our technique can support the comprehension of differences in variants' test cases, and also highlight future research opportunities.",2022,2022-10-16 23:12:59,2022-10-16 23:12:59,,131–141,,,,,,,SPLC '22,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Graz, Austria",,,,feature forks; merging; test cases; variant-rich systems,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
5UB7A8VE,conferencePaper,2022,"Li, Zongjie; Ma, Pingchuan; Wang, Huaijin; Wang, Shuai; Tang, Qiyi; Nie, Sen; Wu, Shi",Unleashing the Power of Compiler Intermediate Representation to Enhance Neural Program Embeddings,Proceedings of the 44th International Conference on Software Engineering,978-1-4503-9221-1,,10.1145/3510003.3510217,https://doi.org/10.1145/3510003.3510217,"Neural program embeddings have demonstrated considerable promise in a range of program analysis tasks, including clone identification, program repair, code completion, and program synthesis. However, most existing methods generate neural program embeddings directly from the program source codes, by learning from features such as tokens, abstract syntax trees, and control flow graphs.This paper takes a fresh look at how to improve program embeddings by leveraging compiler intermediate representation (IR). We first demonstrate simple yet highly effective methods for enhancing embedding quality by training embedding models alongside source code and LLVM IR generated by default optimization levels (e.g., -O2). We then introduce IRGen, a framework based on genetic algorithms (GA), to identify (near-)optimal sequences of optimization flags that can significantly improve embedding quality.We use IRGen to find optimal sequences of LLVM optimization flags by performing GA on source code datasets. We then extend a popular code embedding model, CodeCMR, by adding a new objective based on triplet loss to enable a joint learning over source code and LLVM IR. We benchmark the quality of embedding using a representative downstream application, code clone detection. When CodeCMR was trained with source code and LLVM IRs optimized by findings of IRGen, the embedding quality was significantly improved, outperforming the state-of-the-art model, CodeBERT, which was trained only with source code. Our augmented CodeCMR also outperformed CodeCMR trained over source code and IR optimized with default optimization levels. We investigate the properties of optimization flags that increase embedding quality, demonstrate IRGen's generalization in boosting other embedding models, and establish IRGen's use in settings with extremely limited training data. Our research and findings demonstrate that a straightforward addition to modern neural code embedding models can provide a highly effective enhancement.",2022,2022-10-16 23:12:59,2022-10-16 23:12:59,,2253–2265,,,,,,,ICSE '22,,,,Association for Computing Machinery,"New York, NY, USA",,,,,,,,"event-place: Pittsburgh, Pennsylvania",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
WAIYH2PZ,journalArticle,2021,"Keller, Patrick; Kaboré, Abdoul Kader; Plein, Laura; Klein, Jacques; Le Traon, Yves; Bissyandé, Tegawendé F.",What You See is What It Means! Semantic Representation Learning of Code Based on Visualization and Transfer Learning,ACM Trans. Softw. Eng. Methodol.,,1049-331X,10.1145/3485135,https://doi.org/10.1145/3485135,"Recent successes in training word embeddings for Natural Language Processing (NLP) tasks have encouraged a wave of research on representation learning for source code, which builds on similar NLP methods. The overall objective is then to produce code embeddings that capture the maximum of program semantics. State-of-the-art approaches invariably rely on a syntactic representation (i.e., raw lexical tokens, abstract syntax trees, or intermediate representation tokens) to generate embeddings, which are criticized in the literature as non-robust or non-generalizable. In this work, we investigate a novel embedding approach based on the intuition that source code has visual patterns of semantics. We further use these patterns to address the outstanding challenge of identifying semantic code clones. We propose the WySiWiM&nbsp;(‘‘What You See Is What It Means”) approach where visual representations of source code are fed into powerful pre-trained image classification neural networks from the field of computer vision to benefit from the practical advantages of transfer learning. We evaluate the proposed embedding approach on the task of vulnerable code prediction in source code and on two variations of the task of semantic code clone identification: code clone detection (a binary classification problem), and code classification (a multi-classification problem). We show with experiments on the BigCloneBench (Java), Open Judge (C) that although simple, our WySiWiM &nbsp;approach performs as effectively as state-of-the-art approaches such as ASTNN or TBCNN. We also showed with data from NVD and SARD that WySiWiM &nbsp;representation can be used to learn a vulnerable code detector with reasonable performance (accuracy ∼90%). We further explore the influence of different steps in our approach, such as the choice of visual representations or the classification algorithm, to eventually discuss the promises and limitations of this research direction.",2021-12,2022-10-16 23:12:59,2022-10-16 23:12:59,,,,2.0,31.0,,,,,,,,,,,,,,,,,"Place: New York, NY, USA Publisher: Association for Computing Machinery",,,,Semantic clones; embedding; representation learning; visual representation,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
