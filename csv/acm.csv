"Key","Item Type","Publication Year","Author","Title","Publication Title","ISBN","ISSN","DOI","Url","Abstract Note","Date","Date Added","Date Modified","Access Date","Pages","Num Pages","Issue","Volume","Number Of Volumes","Journal Abbreviation","Short Title","Series","Series Number","Series Text","Series Title","Publisher","Place","Language","Rights","Type","Archive","Archive Location","Library Catalog","Call Number","Extra","Notes","File Attachments","Link Attachments","Manual Tags","Automatic Tags","Editor","Series Editor","Translator","Contributor","Attorney Agent","Book Author","Cast Member","Commenter","Composer","Cosponsor","Counsel","Interviewer","Producer","Recipient","Reviewed Author","Scriptwriter","Words By","Guest","Number","Edition","Running Time","Scale","Medium","Artwork Size","Filing Date","Application Number","Assignee","Issuing Authority","Country","Meeting Name","Conference Name","Court","References","Reporter","Legal Status","Priority Numbers","Programming Language","Version","System","Code","Code Number","Section","Session","Committee","History","Legislative Body"
"98VMXQJY","conferencePaper","2017","Hu, Yikun; Zhang, Yuanyuan; Li, Juanru; Gu, Dawu","Binary Code Clone Detection across Architectures and Compiling Configurations","Proceedings of the 25th International Conference on Program Comprehension","978-1-5386-0535-6","","10.1109/ICPC.2017.22","https://doi.org/10.1109/ICPC.2017.22","Binary code clone detection (or similarity comparison) is a fundamental technique for many important applications, such as plagiarism detection, malware analysis, software vulnerability assessment and program comprehension. With the prevailing of smart and IoT (Internet of Things) devices, more and more programs are ported from traditional desktop platforms (e.g., IA-32) to ARM and MIPS architectures. It becomes imperative to detect cloned binary code across architectures. However, because of incomparable instruction sets of different architectures as well as alternative compiling configurations, it is difficult to conduct a binary code clone detection with traditional syntax- or structure-based methods.To address, we propose a semantics-based approach to fulfill the target. We recognize arguments and indirect jump targets of each binary function, and emulate executions of those functions, extracting semantic signatures to measure the similarity of functions. The approach has been implemented in a prototype system named CACompare to detect cloned binary functions across architectures and compiling configurations. It supports comparisons between mainstream architectures (IA-32, ARM and MIPS) and is able to analyse binaries on the Linux platform. The experimental results show that CACompare not only is effective in dealing with binaries of different architectures and variant compiling configurations, but also improves the accuracy of binary code clone detection comparing to state-of-the-art solutions.","2017","2022-10-16 23:12:58","2022-10-16 23:12:58","","88–98","","","","","","","ICPC '17","","","","IEEE Press","","","","","","","","","event-place: Buenos Aires, Argentina","","","","code clone detection; binary program analysis; reverse engineering; static analysis","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"UIWF3QC5","conferencePaper","2022","Huang, Cheng; Zhou, Hui; Ye, Chunyang; Li, Bingzhuo","Code Clone Detection Based on Event Embedding and Event Dependency","Proceedings of the 13th Asia-Pacific Symposium on Internetware","978-1-4503-9780-3","","10.1145/3545258.3545277","https://doi.org/10.1145/3545258.3545277","The code clone detection method based on semantic similarity has important value in software engineering tasks (e.g., software evolution, software reuse). Traditional code clone detection technologies pay more attention to the similarity of code at the syntax level, and less attention to the semantic similarity of the code. As a result, candidate codes similar in semantics are ignored. To address this issue, we propose a code clone detection method based on semantic similarity. By treating code as a series of interdependent events that occur continuously, we design a model namely EDAM to encode code semantic information based on event embedding and event dependency. The EDAM model uses the event embedding method to model the execution characteristics of program statements and the data dependence information between all statements. In this way, we can embed the program semantic information into a vector and use the vector to detect codes similar in semantics. Experimental results show that the performance of our EDAM model is superior to state-of-the-art open source models for code clone detection.","2022","2022-10-16 23:12:58","2022-10-16 23:12:58","","65–74","","","","","","","Internetware '22","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Hohhot, China","","","","code clone detection; event dependency; event embedding","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"6HL2Q9CZ","conferencePaper","2020","Svacina, Jan; Simmons, Jonathan; Cerny, Tomas","Semantic Code Clone Detection for Enterprise Applications","Proceedings of the 35th Annual ACM Symposium on Applied Computing","978-1-4503-6866-7","","10.1145/3341105.3374117","https://doi.org/10.1145/3341105.3374117","Enterprise systems are widely adopted across industries as methods of solving complex problems. As software complexity increases, the software's codebase becomes harder to manage and maintenance costs raise significantly. One such source of cost-raising complexity and code bloat is that of code clones. We proposed an approach to identify semantic code clones in enterprise frameworks by using control flow graphs (CFGs) and applying various proprietary similarity functions to compare enterprise targeted metadata for each pair of CFGs. This approach enables us to detect semantic code clones with high accuracy within a time complexity of O(n2) where n is equal to the number of CFGs composed in the enterprise application (usually around hundreds). We demonstrated our solution on a blind study utilizing a production enterprise application.","2020","2022-10-16 23:12:58","2022-10-16 23:12:58","","129–131","","","","","","","SAC '20","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Brno, Czech Republic","","","","code clone detection; enterprise software; semantic clone; software engineering; source code analysis","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"GYBS27KX","journalArticle","2021","Hemel, Armijn; Kalleberg, Karl Trygve; Vermaas, Rob; Dolstra, Eelco","Finding Software License Violations Through Binary Code Clone Detection - A Retrospective","SIGSOFT Softw. Eng. Notes","","0163-5948","10.1145/3468744.3468752","https://doi.org/10.1145/3468744.3468752","Ten years ago, we published the article Finding software license violations through binary code clone detection at the MSR 2011 conference. Our paper was motivated by the tendency of em- bedded hardware vendors to only release binary blobs of their rmware, often violating the licensing terms of open-source soft- ware present inside those blobs. The techniques presented in our paper were designed to accurately identify open-source code hid- den inside binary blobs. Here, we give our perspectives on the impact of our work, both industrially and academically, and re- visit the original problem statement to see what has happened in the eld of open-source compliance in the intervening decade.","2021-07","2022-10-16 23:12:58","2022-10-16 23:12:58","","24–25","","3","46","","","","","","","","","","","","","","","","","Place: New York, NY, USA Publisher: Association for Computing Machinery","","","","code clone detection; binary analysis; repository mining; rmware","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"GLTJB5T5","journalArticle","2020","Walker, Andrew; Cerny, Tomas","On Cloud Computing Infrastructure for Existing Code-Clone Detection Algorithms","SIGAPP Appl. Comput. Rev.","","1559-6915","10.1145/3392350.3392351","https://doi.org/10.1145/3392350.3392351","Microservice Architecture (MSA) is becoming a design standard for modern cloud-based software systems. However, even though cloud-based applications have been thoroughly explored with regards to networking, scalability, and decomposition of existing monolithic applications into MSA based applications, not much research has been done showing the viability of MSA in new problem domains. In this paper, we explore the application of MSA to the code-clone detection problem domain to identify any improvements that can be made over existing local code-clone detection applications. A fragment of source code that is identical or similar to another is a code-clone. Code-clones make it difficult to maintain applications as they create multiple points within the code that bugs must be fixed, new rules enforced, or design decisions imposed. As applications grow larger and larger, the pervasiveness of code-clones likewise grows. To face the code-clone related issues, many tools and algorithms have been proposed to find and document code-clones within an application. In this paper, we show that many improvements can be made by utilizing emerging cloud-based technologies.","2020-04","2022-10-16 23:12:58","2022-10-16 23:12:58","","5–14","","1","20","","","","","","","","","","","","","","","","","Place: New York, NY, USA Publisher: Association for Computing Machinery","","","","clone detection; cloud computing; code clone; microservices; scalable code clone detection; software as a service","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"XMFR8TRI","conferencePaper","2020","Fang, Chunrong; Liu, Zixi; Shi, Yangyang; Huang, Jeff; Shi, Qingkai","Functional Code Clone Detection with Syntax and Semantics Fusion Learning","Proceedings of the 29th ACM SIGSOFT International Symposium on Software Testing and Analysis","978-1-4503-8008-9","","10.1145/3395363.3397362","https://doi.org/10.1145/3395363.3397362","Clone detection of source code is among the most fundamental software engineering techniques. Despite intensive research in the past decade, existing techniques are still unsatisfactory in detecting ""functional"" code clones. In particular, existing techniques cannot efficiently extract syntax and semantics information from source code. In this paper, we propose a novel joint code representation that applies fusion embedding techniques to learn hidden syntactic and semantic features of source codes. Besides, we introduce a new granularity for functional code clone detection. Our approach regards the connected methods with caller-callee relationships as a functionality and the method without any caller-callee relationship with other methods represents a single functionality. Then we train a supervised deep learning model to detect functional code clones. We conduct evaluations on a large dataset of C++ programs and the experimental results show that fusion learning can significantly outperform the state-of-the-art techniques in detecting functional code clones.","2020","2022-10-16 23:12:58","2022-10-16 23:12:58","","516–527","","","","","","","ISSTA 2020","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Virtual Event, USA","","","","Code clone detection; code representation; functional clone detection; syntax and semantics fusion learning","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"RAGQNY2A","conferencePaper","2019","Ul Ain, Qurat; Azam, Farooque; Anwar, Muhammad Waseem; Kiran, Ayesha","A Model-Driven Approach for Token Based Code Clone Detection Techniques - An Introduction to UMLCCD","Proceedings of the 2019 8th International Conference on Educational and Information Technology","978-1-4503-6267-2","","10.1145/3318396.3318440","https://doi.org/10.1145/3318396.3318440","Reusing code through copy and paste is a well-known process in software development. The replicated code is known as code clone and the process is known as code cloning. Software clones can cause bug propagation and severe issues related to maintenance. Code clone detection process consist of many steps, which is complex to some extent for user to perform. Therefore, we are trying to propose a generic approach for code clone detection approaches at model level. This study particularly presents Unified Modeling Language profile for Code Clone Detection (UMLCCD) to model the process of token-based code clone detection approaches as token-based approaches has good execution time while maintaining high precision and recall. It automate the clone detection process of token-based approaches which is helpful for user because user simply gives input and whole process is done automatically. It can be used for source code of various programming languages. The proposed UML profile provides the bases to transform the UMLCCD source model into required text. The applicability of UMLCCD is validated by taking 484 lines of source code of Library Management System case study.","2019","2022-10-16 23:12:58","2022-10-16 23:12:58","","312–317","","","","","","","ICEIT 2019","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Cambridge, United Kingdom","","","","Code clone detection; MDA; Token based approaches; UMLCCD","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"83A2IP8B","conferencePaper","2022","Huang, Jun","Code Clone Detection Based on Doc2vec Model and Bagging","Proceedings of the 2022 2nd International Conference on Control and Intelligent Robotics","978-1-4503-9717-9","","10.1145/3548608.3559280","https://doi.org/10.1145/3548608.3559280","For software analysis and maintenance, the code clone detection has an important role. In order to improve the detection rate of code clone, this paper proposes a code cloning detection method based on Doc2vec model and bagging. Firstly, method converts the code into token sequence and abstract syntax tree sequence. Then, the Doc2vec model is used to learn the lexical and grammatical information of the code respectively. Finally, bagging algorithm is used to detect the cloning of code pairs. The results show that the accuracy and recall of the code clone detection method based on Doc2vec model and bagging is better than that of sourcerercc and tree LSTM on bigclonebench data set.","2022","2022-10-16 23:12:58","2022-10-16 23:12:58","","649–653","","","","","","","ICCIR '22","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Nanjing, China","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"C87RHVXD","conferencePaper","2017","Dang, Yingnong; Zhang, Dongmei; Ge, Song; Huang, Ray; Chu, Chengyun; Xie, Tao","Transferring Code-Clone Detection and Analysis to Practice","Proceedings of the 39th International Conference on Software Engineering: Software Engineering in Practice Track","978-1-5386-2717-4","","10.1109/ICSE-SEIP.2017.6","https://doi.org/10.1109/ICSE-SEIP.2017.6","During software development, code clones are commonly produced, in the form of a number of the same or similar code fragments spreading within one or many large code bases. Numerous research projects have been carried out on empirical studies or tool support for detecting or analyzing code clones. However, in practice, few such research projects have resulted in substantial industry adoption. In this paper, we report our experiences of transferring XIAO, a code-clone detection and analysis approach and its supporting tool, to broad industrial practices: (1) shipped in Visual Studio 2012, a widely used industrial IDE; (2) deployed and intensively used at the Microsoft Security Response Center. According to our experiences, technology transfer is a rather complicated journey that needs significant efforts from both the technical aspect and social aspect. From the technical aspect, significant efforts are needed to adapt a research prototype to a product-quality tool that addresses the needs of real scenarios, to be integrated into a mainstream product or development process. From the social aspect, there are strong needs to interact with practitioners to identify killer scenarios in industrial settings, figure out the gap between a research prototype and a tool fitting the needs of real scenarios, to understand the requirements of releasing with a mainstream product, being integrated into a development process, understanding their release cadence, etc.","2017","2022-10-16 23:12:58","2022-10-16 23:12:58","","53–62","","","","","","","ICSE-SEIP '17","","","","IEEE Press","","","","","","","","","event-place: Buenos Aires, Argentina","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"GPV9LPE4","journalArticle","2020","Walker, Andrew; Cerny, Tomas; Song, Eungee","Open-Source Tools and Benchmarks for Code-Clone Detection: Past, Present, and Future Trends","SIGAPP Appl. Comput. Rev.","","1559-6915","10.1145/3381307.3381310","https://doi.org/10.1145/3381307.3381310","A fragment of source code that is identical or similar to another is a code-clone. Code-clones make it difficult to maintain applications as they create multiple points within the code that bugs must be fixed, new rules enforced, or design decisions imposed. As applications grow larger and larger, the pervasiveness of code-clones likewise grows. To face the code-clone related issues, many tools and algorithms have been proposed to find and document code-clones within an application. In this paper, we present the historical trends in code-clone detection tools to show how we arrived at the current implementations. We then present our results from a systematic mapping study on current (2009-2019) code-clone detection tools with regards to technique, open-source nature, and language coverage. Lastly, we propose future directions for code-clone detection tools. This paper provides the essentials to understanding the code-clone detection process and the current state-of-art solutions.","2020-01","2022-10-16 23:12:58","2022-10-16 23:12:58","","28–39","","4","19","","","","","","","","","","","","","","","","","Place: New York, NY, USA Publisher: Association for Computing Machinery","","","","clone detection; code clone; mapping study; survey","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"9NGN7EB5","conferencePaper","2018","Xue, Hongfa; Venkataramani, Guru; Lan, Tian","Clone-Hunter: Accelerated Bound Checks Elimination via Binary Code Clone Detection","Proceedings of the 2nd ACM SIGPLAN International Workshop on Machine Learning and Programming Languages","978-1-4503-5834-7","","10.1145/3211346.3211347","https://doi.org/10.1145/3211346.3211347","Unsafe pointer usage and illegitimate memory accesses are prevalent bugs in software. To ensure memory safety, conditions for array bound checks are inserted into the code to detect out-of-bound memory accesses. Unfortunately, these bound checks contribute to high runtime overheads, and therefore, redundant array bound checks should be removed to improve application performance. In this paper, we propose Clone-Hunter, a practical and scalable framework for redundant bound check elimination in binary executables. Clone-Hunter first uses binary code clone detection, and then employs bound safety verification mechanism (using binary symbolic execution) to ensure sound removal of redundant bound checks. Our results show the Clone-Hunter can swiftly identify redundant bound checks about 90× faster than pure binary symbolic execution, while ensuring zero false positives.","2018","2022-10-16 23:12:58","2022-10-16 23:12:58","","11–19","","","","","","","MAPL 2018","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Philadelphia, PA, USA","","","","Array bound checks; Binary analysis; Machine learning; Memory safety","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"AAZ7U9UX","conferencePaper","2019","Elkhail, Abdulrahman Abu; Svacina, Jan; Cerny, Tomas","Intelligent Token-Based Code Clone Detection System for Large Scale Source Code","Proceedings of the Conference on Research in Adaptive and Convergent Systems","978-1-4503-6843-8","","10.1145/3338840.3355654","https://doi.org/10.1145/3338840.3355654","A code clone refers to code fragments in the source code that are identical or similar to each other. Code clones lead difficulties in software maintenance, bug fixing, present poor design and increase the system size. Code clone detection techniques and tools have been proposed by many researchers, however, there is a lack of clone detection techniques especially for large scale repositories. In this paper, we present a token-based clone detector called Intelligent Clone Detection Tool (ICDT) that can detect both exact and near-miss clones from large repositories using a standard workstation environment. In order to evaluate the scalability and the efficiency of ICDT, we use the most recent benchmark which is a big benchmark of real clones, BigCloneBench. In addition, we compare ICDT to four publicly available and state-of-the-art tools.","2019","2022-10-16 23:12:58","2022-10-16 23:12:58","","256–260","","","","","","","RACS '19","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Chongqing, China","","","","clone detection; code clone; BigCloneBench; case study","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"8FTUWLZA","conferencePaper","2019","Nafi, Kawser Wazed; Kar, Tonny Shekha; Roy, Banani; Roy, Chanchal K.; Schneider, Kevin A.","CLCDSA: Cross Language Code Clone Detection Using Syntactical Features and API Documentation","Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering","978-1-72812-508-4","","10.1109/ASE.2019.00099","https://doi.org/10.1109/ASE.2019.00099","Software clones are detrimental to software maintenance and evolution and as a result many clone detectors have been proposed. These tools target clone detection in software applications written in a single programming language. However, a software application may be written in different languages for different platforms to improve the application's platform compatibility and adoption by users of different platforms. Cross language clones (CLCs) introduce additional challenges when maintaining multi-platform applications and would likely go undetected using existing tools. In this paper, we propose CLCDSA, a cross language clone detector which can detect CLCs without extensive processing of the source code and without the need to generate an intermediate representation. The proposed CLCDSA model analyzes different syntactic features of source code across different programming languages to detect CLCs. To support large scale clone detection, the CLCDSA model uses an action filter based on cross language API call similarity to discard non-potential clones. The design methodology of CLCDSA is twofold: (a) it detects CLCs on the fly by comparing the similarity of features, and (b) it uses a deep neural network based feature vector learning model to learn the features and detect CLCs. Early evaluation of the model observed an average precision, recall and F-measure score of 0.55, 0.86, and 0.64 respectively for the first phase and 0.61, 0.93, and 0.71 respectively for the second phase which indicates that CLCDSA outperforms all available models in detecting cross language clones.","2019","2022-10-16 23:12:58","2022-10-16 23:12:58","","1026–1037","","","","","","","ASE '19","","","","IEEE Press","","","","","","","","","event-place: San Diego, California","","","","code clone; API documentation; source code syntax; Word2Vector","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"WRF6UWP3","conferencePaper","2019","Dann, Andreas; Hermann, Ben; Bodden, Eric","SootDiff: Bytecode Comparison across Different Java Compilers","Proceedings of the 8th ACM SIGPLAN International Workshop on State Of the Art in Program Analysis","978-1-4503-6720-2","","10.1145/3315568.3329966","https://doi.org/10.1145/3315568.3329966","Different Java compilers and compiler versions, e.g., javac or ecj, produce different bytecode from the same source code. This makes it hard to trace if the bytecode of an open-source library really matches the provided source code. Moreover, it prevents one from detecting which open-source libraries have been re-compiled and rebundled into a single jar, which is a common way to distribute an application. Such rebundling is problematic because it prevents one to check if the jar file contains open-source libraries with known vulnerabilities. To cope with these problems, we propose the tool SootDiff that uses Soot's intermediate representation Jimple, in combination with code clone detection techniques, to reduce dissimilarities introduced by different compilers, and to identify clones. Our results show that SootDiff successfully identifies clones in 102 of 144 cases, whereas bytecode comparison succeeds in 58 cases only.","2019","2022-10-16 23:12:58","2022-10-16 23:12:58","","14–19","","","","","","","SOAP 2019","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Phoenix, AZ, USA","","","","Code Clone Detection; Intermediate Representation; Static Analysis","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"K2XVWTN7","journalArticle","2020","Wang, Wenhan; Li, Ge; Shen, Sijie; Xia, Xin; Jin, Zhi","Modular Tree Network for Source Code Representation Learning","ACM Trans. Softw. Eng. Methodol.","","1049-331X","10.1145/3409331","https://doi.org/10.1145/3409331","Learning representation for source code is a foundation of many program analysis tasks. In recent years, neural networks have already shown success in this area, but most existing models did not make full use of the unique structural information of programs. Although abstract syntax tree (AST)-based neural models can handle the tree structure in the source code, they cannot capture the richness of different types of substructure in programs. In this article, we propose a modular tree network that dynamically composes different neural network units into tree structures based on the input AST. Different from previous tree-structural neural network models, a modular tree network can capture the semantic differences between types of AST substructures. We evaluate our model on two tasks: program classification and code clone detection. Our model achieves the best performance compared with state-of-the-art approaches in both tasks, showing the advantage of leveraging more elaborate structure information of the source code.","2020-09","2022-10-16 23:12:58","2022-10-16 23:12:58","","","","4","29","","","","","","","","","","","","","","","","","Place: New York, NY, USA Publisher: Association for Computing Machinery","","","","code clone detection; neural networks; Deep learning; program classification","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"W9D7NNDH","conferencePaper","2019","Zhang, Jian; Wang, Xu; Zhang, Hongyu; Sun, Hailong; Wang, Kaixuan; Liu, Xudong","A Novel Neural Source Code Representation Based on Abstract Syntax Tree","Proceedings of the 41st International Conference on Software Engineering","","","10.1109/ICSE.2019.00086","https://doi.org/10.1109/ICSE.2019.00086","Exploiting machine learning techniques for analyzing programs has attracted much attention. One key problem is how to represent code fragments well for follow-up analysis. Traditional information retrieval based methods often treat programs as natural language texts, which could miss important semantic information of source code. Recently, state-of-the-art studies demonstrate that abstract syntax tree (AST) based neural models can better represent source code. However, the sizes of ASTs are usually large and the existing models are prone to the long-term dependency problem. In this paper, we propose a novel AST-based Neural Network (ASTNN) for source code representation. Unlike existing models that work on entire ASTs, ASTNN splits each large AST into a sequence of small statement trees, and encodes the statement trees to vectors by capturing the lexical and syntactical knowledge of statements. Based on the sequence of statement vectors, a bidirectional RNN model is used to leverage the naturalness of statements and finally produce the vector representation of a code fragment. We have applied our neural network based source code representation method to two common program comprehension tasks: source code classification and code clone detection. Experimental results on the two tasks indicate that our model is superior to state-of-the-art approaches.","2019","2022-10-16 23:12:58","2022-10-16 23:12:58","","783–794","","","","","","","ICSE '19","","","","IEEE Press","","","","","","","","","event-place: Montreal, Quebec, Canada","","","","code clone detection; abstract syntax tree; code classification; neural network; source code representation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"E6J2YFYA","conferencePaper","2020","Rost, Wolf","Mining of DSLs and Generator Templates from Reference Applications","Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings","978-1-4503-8135-2","","10.1145/3417990.3419492","https://doi.org/10.1145/3417990.3419492","Domain-Specific Languages (DSLs) found application in different domains. The development of Model-Driven Development (MDD) components is facilitated by a wealth of frameworks like EMF, Xtext, and Xtend. However, the development of the necessary IDE components still can take up to several weeks or even months until it can be used in a production environment. The first step during the development of such an MDD infrastructure is to analyse a set of reference applications to deduce the DSL used by the domain experts and the templates used in the generator. The analysis requires technical expertise and is usually performed by MDD infrastructure developers, who have to adhere to a close communication with domain experts and are exposed to high cognitive load and time-consuming tasks.The objective of this PhD project is to reduce the initial effort during the creation of new MDD infrastructure facilities for either a new domain or newly discovered platforms within a known domain. This should be made possible by the (semi-)automatic analysis of multiple codebases using Code Clone Detection (CCD) tools in a defined process flow. Code clones represent schematically redundant and generic code fragments which were found in the provided codebase. In the process, the key steps include (i) choosing appropriate reference applications (ii) distinguishing the codebase by clustering the files, (iii) reviewing the quality of the clusters, (iv) analysing the cluster by tailored CCD, and (v) transforming of the code clones, depending on the code clone type, to extract a DSL and the corresponding generator templates.","2020","2022-10-16 23:12:58","2022-10-16 23:12:58","","","","","","","","","MODELS '20","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Virtual Event, Canada","","","","code clone detection; clustering and classification; information extraction; MDD component creation; model-driven software engineering","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"K5SA3L3D","conferencePaper","2017","Duan, Ruian; Bijlani, Ashish; Xu, Meng; Kim, Taesoo; Lee, Wenke","Identifying Open-Source License Violation and 1-Day Security Risk at Large Scale","Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security","978-1-4503-4946-8","","10.1145/3133956.3134048","https://doi.org/10.1145/3133956.3134048","With millions of apps available to users, the mobile app market is rapidly becoming very crowded. Given the intense competition, the time to market is a critical factor for the success and profitability of an app. In order to shorten the development cycle, developers often focus their efforts on the unique features and workflows of their apps and rely on third-party Open Source Software (OSS) for the common features. Unfortunately, despite their benefits, careless use of OSS can introduce significant legal and security risks, which if ignored can not only jeopardize security and privacy of end users, but can also cause app developers high financial loss. However, tracking OSS components, their versions, and interdependencies can be very tedious and error-prone, particularly if an OSS is imported with little to no knowledge of its provenance.We therefore propose OSSPolice, a scalable and fully-automated tool for mobile app developers to quickly analyze their apps and identify free software license violations as well as usage of known vulnerable versions of OSS. OSSPolice introduces a novel hierarchical indexing scheme to achieve both high scalability and accuracy, and is capable of efficiently comparing similarities of app binaries against a database of hundreds of thousands of OSS sources (billions of lines of code). We populated OSSPolice with 60K C/C++ and 77K Java OSS sources and analyzed 1.6M free Google Play Store apps. Our results show that 1) over 40K apps potentially violate GPL/AGPL licensing terms, and 2) over 100K of apps use known vulnerable versions of OSS. Further analysis shows that developers violate GPL/AGPL licensing terms due to lack of alternatives, and use vulnerable versions of OSS despite efforts from companies like Google to improve app security. OSSPolice is available on GitHub.","2017","2022-10-16 23:12:58","2022-10-16 23:12:58","","2169–2185","","","","","","","CCS '17","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Dallas, Texas, USA","","","","code clone detection; application security; license violation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"C3M2UPPX","journalArticle","2022","Yu, Hao; Hu, Xing; Li, Ge; Li, Ying; Wang, Qianxiang; Xie, Tao","Assessing and Improving an Evaluation Dataset for Detecting Semantic Code Clones via Deep Learning","ACM Trans. Softw. Eng. Methodol.","","1049-331X","10.1145/3502852","https://doi.org/10.1145/3502852","In recent years, applying deep learning to detect semantic code clones has received substantial attention from the research community. Accordingly, various evaluation benchmark datasets, with the most popular one as BigCloneBench, are constructed and selected as benchmarks to assess and compare different deep learning models for detecting semantic clones. However, there is no study to investigate whether an evaluation benchmark dataset such as BigCloneBench is properly used to evaluate models for detecting semantic code clones. In this article, we present an experimental study to show that BigCloneBench typically includes semantic clone pairs that use the same identifier names, which however are not used in non-semantic-clone pairs. Subsequently, we propose an undesirable-by-design Linear-Model that considers only which identifiers appear in a code fragment; this model can achieve high effectiveness for detecting semantic clones when evaluated on BigCloneBench, even comparable to state-of-the-art deep learning models recently proposed for detecting semantic clones. To alleviate these issues, we abstract a subset of the identifier names (including type, variable, and method names) in BigCloneBench to result in AbsBigCloneBench and use AbsBigCloneBench to better assess the effectiveness of deep learning models on the task of detecting semantic clones.","2022-07","2022-10-16 23:12:58","2022-10-16 23:12:58","","","","4","31","","","","","","","","","","","","","","","","","Place: New York, NY, USA Publisher: Association for Computing Machinery","","","","deep learning; Code clone detection; dataset collection","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"EBWCAAT2","conferencePaper","2020","Wu, Xiongfei; Qin, Liangyu; Yu, Bing; Xie, Xiaofei; Ma, Lei; Xue, Yinxing; Liu, Yang; Zhao, Jianjun","How Are Deep Learning Models Similar? An Empirical Study on Clone Analysis of Deep Learning Software","Proceedings of the 28th International Conference on Program Comprehension","978-1-4503-7958-8","","10.1145/3387904.3389254","https://doi.org/10.1145/3387904.3389254","Deep learning (DL) has been successfully applied to many cutting-edge applications, e.g., image processing, speech recognition, and natural language processing. As more and more DL software is made open-sourced, publicly available, and organized in model repositories and stores (Model Zoo, ModelDepot), there comes a need to understand the relationships of these DL models regarding their maintenance and evolution tasks. Although clone analysis has been extensively studied for traditional software, up to the present, clone analysis has not been investigated for DL software. Since DL software adopts the data-driven development paradigm, it is still not clear whether and to what extent the clone analysis techniques of traditional software could be adapted to DL software.In this paper, we initiate the first step on the clone analysis of DL software at three different levels, i.e., source code level, model structural level, and input/output (I/0)-semantic level, which would be a key in DL software management, maintenance and evolution. We intend to investigate the similarity between these DL models from clone analysis perspective. Several tools and metrics are selected to conduct clone analysis of DL software at three different levels. Our study on two popular datasets (i.e., MNIST and CIFAR-10) and eight DL models of five architectural families (i.e., LeNet, ResNet, DenseNet, AlexNet, and VGG) shows that: 1). the three levels of similarity analysis are generally adequate to find clones between DL models ranging from structural to semantic; 2). different measures for clone analysis used at each level yield similar results; 3) clone analysis of one single level may not render a complete picture of the similarity of DL models. Our findings open up several research opportunities worth further exploration towards better understanding and more effective clone analysis of DL software.","2020","2022-10-16 23:12:58","2022-10-16 23:12:58","","172–183","","","","","","","ICPC '20","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Seoul, Republic of Korea","","","","deep learning; Code clone detection; model similarity","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"4HCLKFD7","conferencePaper","2019","Wang, Cong; Gao, Jian; Jiang, Yu; Xing, Zhenchang; Zhang, Huafeng; Yin, Weiliang; Gu, Ming; Sun, Jiaguang","Go-Clone: Graph-Embedding Based Clone Detector for Golang","Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis","978-1-4503-6224-5","","10.1145/3293882.3338996","https://doi.org/10.1145/3293882.3338996","Golang (short for Go programming language) is a fast and compiled language, which has been increasingly used in industry due to its excellent performance on concurrent programming. Golang redefines concurrent programming grammar, making it a challenge for traditional clone detection tools and techniques. However, there exist few tools for detecting duplicates or copy-paste related bugs in Golang. Therefore, an effective and efficient code clone detector on Golang is especially needed. In this paper, we present Go-Clone, a learning-based clone detector for Golang. Go-Clone contains two modules – the training module and the user interaction module. In the training module, firstly we parse Golang source code into llvm IR (Intermediate Representation). Secondly, we calculate LSFG (labeled semantic flow graph) for each program function automatically. Go-Clone trains a deep neural network model to encode LSFGs for similarity classification. In the user interaction module, users can choose one or more Golang projects. Go-Clone identifies and presents a list of function pairs, which are most likely clone code for user inspection. To evaluate Go-Clone's performance, we collect 6,110 commit versions from 48 Github projects to construct a Golang clone detection data set. Go-Clone can reach the value of AUC (Area Under Curve) and ACC (Accuracy) for 89.61% and 83.80% in clone detection. By testing several groups of unfamiliar data, we also demonstrates the generility of Go-Clone. The address of the abstract demo video: https://youtu.be/o5DogtYGbeo","2019","2022-10-16 23:12:58","2022-10-16 23:12:58","","374–377","","","","","","","ISSTA 2019","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Beijing, China","","","","code clone detection; code similarity; deep neural network; go programming language","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"HABYMIKD","conferencePaper","2021","Liu, Chenyao; Lin, Zeqi; Lou, Jian-Guang; Wen, Lijie; Zhang, Dongmei","Can Neural Clone Detection Generalize to Unseen Functionalities?","Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering","978-1-66540-337-5","","10.1109/ASE51524.2021.9678907","https://doi.org/10.1109/ASE51524.2021.9678907","Many recently proposed code clone detectors exploit neural networks to capture latent semantics of source code, thus achieving impressive results for detecting semantic clones. These neural clone detectors rely on the availability of large amounts of labeled training data. We identify a key oversight in the current evaluation methodology for neural clone detection: cross-functionality generalization (i.e., detecting semantic clones of which the functionalities are unseen in training). Specifically, we focus on this question: do neural clone detectors truly learn the ability to detect semantic clones, or they just learn how to model specific functionalities in training data while cannot generalize to realistic unseen functionalities? This paper investigates how the generalizability can be evaluated and improved.Our contributions are 3-folds: (1) We propose an evaluation methodology that can systematically measure the cross-functionality generalizability of neural clone detection. Based on this evaluation methodology, an empirical study is conducted and the results indicate that current neural clone detectors cannot generalize well as expected. (2) We conduct empirical analysis to understand key factors that can impact the generalizability. We investigate 3 factors: training data diversity, vocabulary, and locality. Results show that the performance loss on unseen functionalities can be reduced through addressing the out-of-vocabulary problem and increasing training data diversity. (3) We propose a human-in-the-loop mechanism that help adapt neural clone detectors to new code repositories containing lots of unseen functionalities. It improves annotation efficiency with the combination of transfer learning and active learning. Experimental results show that it reduces the amount of annotations by about 88%. Our code and data are publicly available1.","2021","2022-10-16 23:12:58","2022-10-16 23:12:58","","617–629","","","","","","","ASE '21","","","","IEEE Press","","","","","","","","","event-place: Melbourne, Australia","","","","code clone detection; neural network; evaluation methodology; generalization; human-in-the-loop","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"GJA2FAEP","conferencePaper","2020","Mathew, George; Parnin, Chris; Stolee, Kathryn T","SLACC: Simion-Based Language Agnostic Code Clones","Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering","978-1-4503-7121-6","","10.1145/3377811.3380407","https://doi.org/10.1145/3377811.3380407","Successful cross-language clone detection could enable researchers and developers to create robust language migration tools, facilitate learning additional programming languages once one is mastered, and promote reuse of code snippets over a broader codebase. However, identifying cross-language clones presents special challenges to the clone detection problem. A lack of common underlying representation between arbitrary languages means detecting clones requires one of the following solutions: 1) a static analysis framework replicated across each targeted language with annotations matching language features across all languages, or 2) a dynamic analysis framework that detects clones based on runtime behavior.In this work, we demonstrate the feasibility of the latter solution, a dynamic analysis approach called SLACC for cross-language clone detection. Like prior clone detection techniques, we use input/output behavior to match clones, though we overcome limitations of prior work by amplifying the number of inputs and covering more data types; and as a result, achieve better clusters than prior attempts. Since clusters are generated based on input/output behavior, SLACC supports cross-language clone detection. As an added challenge, we target a static typed language, Java, and a dynamic typed language, Python. Compared to HitoshiIO, a recent clone detection tool for Java, SLACC retrieves 6 times as many clusters and has higher precision (86.7% vs. 30.7%).This is the first work to perform clone detection for dynamic typed languages (precision = 87.3%) and the first to perform clone detection across languages that lack a common underlying representation (precision = 94.1%). It provides a first step towards the larger goal of scalable language migration tools.","2020","2022-10-16 23:12:58","2022-10-16 23:12:58","","210–221","","","","","","","ICSE '20","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Seoul, South Korea","","","","cross-language analysis; semantic code clone detection","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"SEN9X5PX","conferencePaper","2017","Krüger, Jacob; Nell, Louis; Fenske, Wolfram; Saake, Gunter; Leich, Thomas","Finding Lost Features in Cloned Systems","Proceedings of the 21st International Systems and Software Product Line Conference - Volume B","978-1-4503-5119-5","","10.1145/3109729.3109736","https://doi.org/10.1145/3109729.3109736","Copying and adapting a system, also known as clone-and-own, is a common reuse approach that requires little initial effort. However, the drawbacks of clones are increasing maintenance costs as bug fixes and updates must be propagated. To reduce these costs, migrating cloned legacy systems towards a software product line promises to enable systematic reuse and customization. For both, managing and migrating cloned systems, it remains a challenge to identify and map features in the systems. In this paper, we i) propose a semi-automatic process to identify and map features between legacy systems, ii) suggest a corresponding visualization approach, and iii) assess our process on a case study. The results indicate that our process is suitable to identify features and present commonalities and variability in cloned systems. Our process can be used to enable traceability, prepare refactorings, and extract software product lines.","2017","2022-10-16 23:12:58","2022-10-16 23:12:58","","65–72","","","","","","","SPLC '17","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Sevilla, Spain","","","","code clone detection; reverse engineering; extractive approach; feature location; legacy system; Software product line","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"6HQAI9X5","conferencePaper","2017","McAfee, Patrick; Mkaouer, Mohamed Wiem; Krutz, Daniel E.","CATE: Concolic Android Testing Using Java Pathfinder for Android Applications","Proceedings of the 4th International Conference on Mobile Software Engineering and Systems","978-1-5386-2669-6","","10.1109/MOBILESoft.2017.35","https://doi.org/10.1109/MOBILESoft.2017.35","Like all software systems, Android applications are not immune to bugs, security vulnerabilities, and a wide range of other runtime errors. Concolic analysis, a hybrid software verification technique which performs symbolic execution along with a concrete execution path, has been used for a variety of purposes including software testing, code clone detection, and security-related activities. We created a new publicly available concolic analysis tool for analyzing Android applications: Concolic Android TEster (CATE). Building on Java Path Finder (JPF-SPF), this tool performs concolic analysis on a raw Android application file (or source code) and provides output in a useful and easy to understand format.","2017","2022-10-16 23:12:58","2022-10-16 23:12:58","","213–214","","","","","","","MOBILESoft '17","","","","IEEE Press","","","","","","","","","event-place: Buenos Aires, Argentina","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"CK49M7NK","journalArticle","2022","Lin, Zehao; Li, Guodun; Zhang, Jingfeng; Deng, Yue; Zeng, Xiangji; Zhang, Yin; Wan, Yao","XCode: Towards Cross-Language Code Representation with Large-Scale Pre-Training","ACM Trans. Softw. Eng. Methodol.","","1049-331X","10.1145/3506696","https://doi.org/10.1145/3506696","Source code representation learning is the basis of applying artificial intelligence to many software engineering tasks such as code clone detection, algorithm classification, and code summarization. Recently, many works have tried to improve the performance of source code representation from various perspectives, e.g., introducing the structural information of programs into latent representation. However, when dealing with rapidly expanded unlabeled cross-language source code datasets from the Internet, there are still two issues. Firstly, deep learning models for many code-specific tasks still suffer from the lack of high-quality labels. Secondly, the structural differences among programming languages make it more difficult to process multiple languages in a single neural architecture.To address these issues, in this article, we propose a novel Cross-language Code representation with a large-scale pre-training (XCode) method. Concretely, we propose to use several abstract syntax trees and ELMo-enhanced variational autoencoders to obtain multiple pre-trained source code language models trained on about 1.5 million code snippets. To fully utilize the knowledge across programming languages, we further propose a Shared Encoder-Decoder (SED) architecture which uses the multi-teacher single-student method to transfer knowledge from the aforementioned pre-trained models to the distilled SED. The pre-trained models and SED will cooperate to better represent the source code. For evaluation, we examine our approach on three typical downstream cross-language tasks, i.e., source code translation, code clone detection, and code-to-code search, on a real-world dataset composed of programming exercises with multiple solutions. Experimental results demonstrate the effectiveness of our proposed approach on cross-language code representations. Meanwhile, our approach performs significantly better than several code representation baselines on different downstream tasks in terms of multiple automatic evaluation metrics.","2022-04","2022-10-16 23:12:58","2022-10-16 23:12:58","","","","3","31","","","","","","","","","","","","","","","","","Place: New York, NY, USA Publisher: Association for Computing Machinery","","","","neural networks; code representation; Deep learning; cross-language; pre-training","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"3QF4IWJX","conferencePaper","2019","Tokumoto, Susumu; Takayama, Kuniharu","PHANTA: Diversified Test Code Quality Measurement for Modern Software Development","Proceedings of the 34th IEEE/ACM International Conference on Automated Software Engineering","978-1-72812-508-4","","10.1109/ASE.2019.00138","https://doi.org/10.1109/ASE.2019.00138","Test code is becoming more essential to the modern software development process. However, practitioners often pay inadequate attention to key aspects of test code quality, such as bug detectability, maintainability and speed. Existing tools also typically report a single test code quality measure, such as code coverage, rather than a diversified set of metrics. To measure and visualize quality of test code in a comprehensive fashion, we developed an integrated test code analysis tool called Phanta. In this show case, we posit that the enhancement of test code quality is key to modernizing software development, and show how Phanta's techniques measure the quality using mutation analysis, test code clone detection, and so on. Further, we present an industrial case study where Phanta was applied to analyze test code in a real Fujitsu project, and share lessons learned from the case study.","2019","2022-10-16 23:12:59","2022-10-16 23:12:59","","1206–1207","","","","","","","ASE '19","","","","IEEE Press","","","","","","","","","event-place: San Diego, California","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"3BYA4M6Y","conferencePaper","2017","Matsushita, Tsubasa; Sasano, Isao","Detecting Code Clones with Gaps by Function Applications","Proceedings of the 2017 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation","978-1-4503-4721-1","","10.1145/3018882.3018892","https://doi.org/10.1145/3018882.3018892","Code clones are pairs or groups of code segments which are identical or similar to each other. Generally the existence of code clones is considered to make it cumbersome to maintain the source code, so that various kinds of code clone detection tools have been developed. Simple ones divide the source code into a sequence of lines or tokens and find identical or similar sub-sequences. Differences among code clones, called gaps, may prevent clones from being detected or may make clones to be detected with being fragmented. In order to cope with gaps, various tools have been developed by using abstract syntax trees, comparing some metrics, or using program dependency graphs. In this paper we present a novel algorithm for detecting clones by focusing on gaps by function applications. Based on the algorithm we have implemented a tool for detecting code clones on programs written in Standard ML.","2017","2022-10-16 23:12:59","2022-10-16 23:12:59","","12–22","","","","","","","PEPM 2017","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Paris, France","","","","code clone; abstract syntax tree; function application; gap","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"FQ4IPPNU","conferencePaper","2018","Xue, Hongfa; Venkataramani, Guru; Lan, Tian","Clone-Slicer: Detecting Domain Specific Binary Code Clones through Program Slicing","Proceedings of the 2018 Workshop on Forming an Ecosystem Around Software Transformation","978-1-4503-5997-9","","10.1145/3273045.3273047","https://doi.org/10.1145/3273045.3273047","In this paper, we presented a novel framework, Clone-Slicer, a domain-specific code clone detector for binary executables, that integrates program slicing and a deep learning based binary code clone modeling framework to improve the number of code clone detected. In particular, we chose pointer analysis for memory safety as our example domain to demonstrate the usefulness of our approach. We evaluated our approach using real-world applications from SPEC 2006 benchmark suite. Our results show Clone-Slicer is able to detect up to 43.64% code clones compared to prior work and further cut the time-to-solution (the time spent to verify memory bound safety) for Clone-Slicer by 32.96% compared to Clone-Hunter. As future work, we plan to apply Clone-Slicer to different domains and tasks, such as vulnerable program path discovery, and further improve the capability for code clone detection through advanced clustering algorithms. We will also study the cost-benefit tradeoffs of using such advanced algorithms.","2018","2022-10-16 23:12:59","2022-10-16 23:12:59","","27–33","","","","","","","FEAST '18","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Toronto, Canada","","","","machine learning; binary analysis; code clones; program slicing","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"DYIJVFYN","conferencePaper","2019","Babur, Önder; Stephan, Matthew","MoCoP: Towards a Model Clone Portal","Proceedings of the 11th International Workshop on Modelling in Software Engineerings","","","10.1109/MiSE.2019.00019","https://doi.org/10.1109/MiSE.2019.00019","Widespread and mature practice of model-driven engineering is leading to a growing number of modeling artifacts and challenges in their management. Model clone detection (MCD) is an important approach for managing and maintaining modeling artifacts. While its counterpart in traditional source code development, code clone detection, is enjoying popularity and more than two decades of development, MCD is still in its infancy in terms of research and tooling. We aim to develop a portal for model clone detection, MoCoP, as a central hub to mitigate adoption barriers and foster MCD research. In this short paper, we present our vision for MoCoP and its features and goals. We discuss MoCoP's key components that we plan on realizing in the short term including public tooling, curated data sets, and a body of MCD knowledge. Our longer term goals include a dedicated service-oriented infrastructure, contests, and forums. We believe MoCoP will strengthen MCD research, tooling, and the community, which in turn will lead to better quality, maintenance, and scalability for model-driven engineering practices.","2019","2022-10-16 23:12:59","2022-10-16 23:12:59","","78–81","","","","","","","MiSE '19","","","","IEEE Press","","","","","","","","","event-place: Montreal, Quebec, Canada","","","","software maintenance; model analytics; model clone detection; model management; model repositories; model-driven engineering","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"IKBZ9P36","conferencePaper","2018","Saini, Vaibhav; Farmahinifarahani, Farima; Lu, Yadong; Baldi, Pierre; Lopes, Cristina V.","Oreo: Detection of Clones in the Twilight Zone","Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering","978-1-4503-5573-5","","10.1145/3236024.3236026","https://doi.org/10.1145/3236024.3236026","Source code clones are categorized into four types of increasing difficulty of detection, ranging from purely textual (Type-1) to purely semantic (Type-4). Most clone detectors reported in the literature work well up to Type-3, which accounts for syntactic differences. In between Type-3 and Type-4, however, there lies a spectrum of clones that, although still exhibiting some syntactic similarities, are extremely hard to detect – the Twilight Zone. Most clone detectors reported in the literature fail to operate in this zone. We present Oreo, a novel approach to source code clone detection that not only detects Type-1 to Type-3 clones accurately, but is also capable of detecting harder-to-detect clones in the Twilight Zone. Oreo is built using a combination of machine learning, information retrieval, and software metrics. We evaluate the recall of Oreo on BigCloneBench, and perform manual evaluation for precision. Oreo has both high recall and precision. More importantly, it pushes the boundary in detection of clones with moderate to weak syntactic similarity in a scalable manner","2018","2022-10-16 23:12:59","2022-10-16 23:12:59","","354–365","","","","","","","ESEC/FSE 2018","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Lake Buena Vista, FL, USA","","","","Clone detection; Machine Learning; Software Metrics","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"HUY2BC26","conferencePaper","2019","Mostaeen, Golam; Svajlenko, Jeffrey; Roy, Banani; Roy, Chanchal K.; Schneider, Kevin A.","CloneCognition: Machine Learning Based Code Clone Validation Tool","Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering","978-1-4503-5572-8","","10.1145/3338906.3341182","https://doi.org/10.1145/3338906.3341182","A code clone is a pair of similar code fragments, within or between software systems. To detect each possible clone pair from a software system while handling the complex code structures, the clone detection tools undergo a lot of generalization of the original source codes. The generalization often results in returning code fragments that are only coincidentally similar and not considered clones by users, and hence requires manual validation of the reported possible clones by users which is often both time-consuming and challenging. In this paper, we propose a machine learning based tool 'CloneCognition' (Open Source Codes: https://github.com/pseudoPixels/CloneCognition ; Video Demonstration: https://www.youtube.com/watch?v=KYQjmdr8rsw) to automate the laborious manual validation process. The tool runs on top of any code clone detection tools to facilitate the clone validation process. The tool shows promising clone classification performance with an accuracy of up to 87.4%. The tool also exhibits significant improvement in the results when compared with state-of-the-art techniques for code clone validation.","2019","2022-10-16 23:12:59","2022-10-16 23:12:59","","1105–1109","","","","","","","ESEC/FSE 2019","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Tallinn, Estonia","","","","Machine Learning; Artificial Neural Network; Clone Management; Code Clones; Validation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"ZGQYYZMG","conferencePaper","2022","Wang, Deze; Jia, Zhouyang; Li, Shanshan; Yu, Yue; Xiong, Yun; Dong, Wei; Liao, Xiangke","Bridging Pre-Trained Models and Downstream Tasks for Source Code Understanding","Proceedings of the 44th International Conference on Software Engineering","978-1-4503-9221-1","","10.1145/3510003.3510062","https://doi.org/10.1145/3510003.3510062","With the great success of pre-trained models, the pretrain-then-finetune paradigm has been widely adopted on downstream tasks for source code understanding. However, compared to costly training a large-scale model from scratch, how to effectively adapt pre-trained models to a new task has not been fully explored. In this paper, we propose an approach to bridge pre-trained models and code-related tasks. We exploit semantic-preserving transformation to enrich downstream data diversity, and help pre-trained models learn semantic features invariant to these semantically equivalent transformations. Further, we introduce curriculum learning to organize the transformed data in an easy-to-hard manner to fine-tune existing pre-trained models.We apply our approach to a range of pre-trained models, and they significantly outperform the state-of-the-art models on tasks for source code understanding, such as algorithm classification, code clone detection, and code search. Our experiments even show that without heavy pre-training on code data, natural language pre-trained model RoBERTa fine-tuned with our lightweight approach could outperform or rival existing code pre-trained models fine-tuned on the above tasks, such as CodeBERT and GraphCodeBERT. This finding suggests that there is still much room for improvement in code pre-trained models.","2022","2022-10-16 23:12:59","2022-10-16 23:12:59","","287–298","","","","","","","ICSE '22","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Pittsburgh, Pennsylvania","","","","curriculum learning; data augmentation; fine-tuning; test-time augmentation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"RN7MZVA6","journalArticle","2022","Zhang, Huangzhao; Fu, Zhiyi; Li, Ge; Ma, Lei; Zhao, Zhehao; Yang, Hua’an; Sun, Yizhe; Liu, Yang; Jin, Zhi","Towards Robustness of Deep Program Processing Models—Detection, Estimation, and Enhancement","ACM Trans. Softw. Eng. Methodol.","","1049-331X","10.1145/3511887","https://doi.org/10.1145/3511887","Deep learning (DL) has recently been widely applied to diverse source code processing tasks in the software engineering (SE) community, which achieves competitive performance (e.g., accuracy). However, the robustness, which requires the model to produce consistent decisions given minorly perturbed code inputs, still lacks systematic investigation as an important quality indicator. This article initiates an early step and proposes a framework CARROT for robustness detection, measurement, and enhancement of DL models for source code processing. We first propose an optimization-based attack technique CARROTA to generate valid adversarial source code examples effectively and efficiently. Based on this, we define the robustness metrics and propose robustness measurement toolkit CARROTM, which employs the worst-case performance approximation under the allowable perturbations. We further propose to improve the robustness of the DL models by adversarial training (CARROTT) with our proposed attack techniques. Our in-depth evaluations on three source code processing tasks (i.e., functionality classification, code clone detection, defect prediction) containing more than 3 million lines of code and the classic or SOTA DL models, including GRU, LSTM, ASTNN, LSCNN, TBCNN, CodeBERT, and CDLH, demonstrate the usefulness of our techniques for ❶ effective and efficient adversarial example detection, ❷ tight robustness estimation, and ❸ effective robustness enhancement.","2022-04","2022-10-16 23:12:59","2022-10-16 23:12:59","","","","3","31","","","","","","","","","","","","","","","","","Place: New York, NY, USA Publisher: Association for Computing Machinery","","","","adversarial attack; big code; robustness enhancement; Source code processing","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"CC9R9B8Q","conferencePaper","2020","Alomari, Hakam W.; Stephan, Matthew","SrcClone: Detecting Code Clones via Decompositional Slicing","Proceedings of the 28th International Conference on Program Comprehension","978-1-4503-7958-8","","10.1145/3387904.3389271","https://doi.org/10.1145/3387904.3389271","Detecting code clones is an established method for comprehending and maintaining systems. One important but challenging form of code clone detection involves detecting semantic clones, which are those that are semantically similar code segments that differ syntactically. Existing approaches to semantic clone detection do not scale well to large code bases and have room for improvement in their precision and recall. In this paper, we present a scalable slicing-based approach for detecting code clones, including semantic clones. We determine code segment similarity based on their corresponding program slices. We take advantage of a lightweight, publicly available, and scalable program slicing approach to compute the necessary information. Our approach uses dependency analysis to find and measure cloned elements, and provides insights into elements of the code that are affected by an entire clone set/class. We have implemented our approach as a tool called srcClone. We evaluate it by comparing it to two semantic clone detectors in terms of clones, performance, and scalability; and perform recall and precision analysis using established benchmark scenarios. In our evaluation, we illustrate our approach is both relatively scalable and accurate. srcClone can also be used by program analysts to run on non-compilable and incomplete source code, which serves comprehension and maintenance tasks very well. We believe our approach is an important advancement in program comprehension that can help improve clone detection practices and provide developers greater insights into their software.","2020","2022-10-16 23:12:59","2022-10-16 23:12:59","","274–284","","","","","","","ICPC '20","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Seoul, Republic of Korea","","","","Clone detection; Code clone; Program slicing; Semantic clones","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"HRHDMY6V","conferencePaper","2021","Vagavolu, Dheeraj; Swarna, Karthik Chandra; Chimalakonda, Sridhar","A Mocktail of Source Code Representations","Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering","978-1-66540-337-5","","10.1109/ASE51524.2021.9678551","https://doi.org/10.1109/ASE51524.2021.9678551","Efficient representation of source code is essential for various software engineering tasks such as code classification and code clone detection. Most recent approaches for representing source code still use AST and do not leverage semantic graphs such as CFG and PDG. One effective technique for representing source code involves extracting paths from the AST and using a learning model to capture program properties. Code2vec is one such path-based approach that uses an attention-based neural network to learn code embeddings which can then be used for various downstream tasks. However, this approach uses only AST and does not leverage CFG and PDG. Even though an integrated graph approach (Code Property Graph) exists for representing source code, it has only been explored in the domain of software security. Moreover, it does not leverage the paths from the individual graphs. Our idea is to extend the path-based approach code2vec to include the semantic graphs CFG and PDG with AST, which is largely unexplored in software engineering. We evaluate our approach on the task of MethodNaming using a C dataset of 730K methods collected from GitHub. In comparison to code2vec, our approach improves the F1 score by 11% on the full dataset and up to 100% with individual projects. We show that semantic features from the CFG and PDG paths drastically improve the performance of the software engineering tasks. We envision that looking at a mocktail of source code representations for various software engineering tasks can lay the foundation for a new line of research and a re-haul of existing research.","2021","2022-10-16 23:12:59","2022-10-16 23:12:59","","1296–1300","","","","","","","ASE '21","","","","IEEE Press","","","","","","","","","event-place: Melbourne, Australia","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"58E6PLL6","conferencePaper","2020","Gholamian, Sina; Ward, Paul A. S.","Logging Statements' Prediction Based on Source Code Clones","Proceedings of the 35th Annual ACM Symposium on Applied Computing","978-1-4503-6866-7","","10.1145/3341105.3373845","https://doi.org/10.1145/3341105.3373845","Log files are widely used to record runtime information of software systems, such as the time-stamp of an event, the unique ID of the source of the log, and a part of the state of task execution. The rich information of logs enables system operators to monitor the runtime behaviors of their systems and further track down system problems in production settings. Although logs are useful, there exists a trade-off between their benefit and cost, and it is a crucial problem to optimize the location and content of log messages in the source code, i.e., ""where and what to log?""Prior research has analyzed logging statements in the source code and proposed ways to predict and suggest the location of log statements in order to partially automate log statement addition to the source code. However, there are gaps and unsolved problems in the literature to fully automate the logging process. Thus, in this research, we perform an experimental study on open-source Java projects and apply code-clone detection methods for log statements' prediction. Our work demonstrates the feasibility of logging automation by predicting the location of a log point in a code snippet based on the existence of a logging statement in its corresponding code clone pair. We propose a Log-Aware Code-Clone Detector (LACC) which achieves a higher accuracy of log prediction when compared to state-of-the-art general-purpose clone detectors. Our analysis shows that 98% of clone snippets match in their logging behavior, and LACC can predict the location of logging statements by the accuracy of 90+% for Apache Java projects.","2020","2022-10-16 23:12:59","2022-10-16 23:12:59","","82–91","","","","","","","SAC '20","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Brno, Czech Republic","","","","software engineering; code clones; automation; logging statement; source code","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"R4YAN5AR","conferencePaper","2022","Schulze, Sandro; Krüger, Jacob; Wünsche, Johannes","Towards Developer Support for Merging Forked Test Cases","Proceedings of the 26th ACM International Systems and Software Product Line Conference - Volume A","978-1-4503-9443-7","","10.1145/3546932.3547002","https://doi.org/10.1145/3546932.3547002","Developers rely on branching and forking mechanisms of modern versioning systems to evolve and maintain their software systems. As a result, systems often exist in the form of various short-living or even long-living (i.e., clone &amp; own development) variants. Such variants may have to be merged with the main system or other variants, for instance, to propagate features or bug fixes. Within such merging processes, test cases are highly interesting, since they allow to improve the test coverage and hopefully the reliability of the system (e.g., by merging missing tests and bug fixes in test code). However, as all source code, test cases may evolve independently between two or more variants, which makes it non-trivial to decide what changes of the test cases are relevant for the merging. For instance, some test cases in one variant may be irrelevant in another variant (e.g., because the feature shall not be propagated) or may subsume existing test cases. In this paper, we propose a technique that allows for a fine-grained comparison of test cases to support developers in deciding whether and how to merge these. Precisely, inspired by code-clone detection, we use abstract syntax trees to decide on the relations between test cases of different variants. We evaluate the applicability of our technique qualitatively on five open-source systems written in Java (e.g., JUnit 5, Guava). Our insights into the merge potential of 50 pull requests with test cases from these systems indicate that our technique can support the comprehension of differences in variants' test cases, and also highlight future research opportunities.","2022","2022-10-16 23:12:59","2022-10-16 23:12:59","","131–141","","","","","","","SPLC '22","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Graz, Austria","","","","feature forks; merging; test cases; variant-rich systems","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"BSZQGEER","conferencePaper","2020","Wu, Yueming; Zou, Deqing; Dou, Shihan; Yang, Siru; Yang, Wei; Cheng, Feng; Liang, Hong; Jin, Hai","SCDetector: Software Functional Clone Detection Based on Semantic Tokens Analysis","Proceedings of the 35th IEEE/ACM International Conference on Automated Software Engineering","978-1-4503-6768-4","","10.1145/3324884.3416562","https://doi.org/10.1145/3324884.3416562","Code clone detection is to find out code fragments with similar functionalities, which has been more and more important in software engineering. Many approaches have been proposed to detect code clones, in which token-based methods are the most scalable but cannot handle semantic clones because of the lack of consideration of program semantics. To address the issue, researchers conduct program analysis to distill the program semantics into a graph representation and detect clones by matching the graphs. However, such approaches suffer from low scalability since graph matching is typically time-consuming.In this paper, we propose SCDetector to combine the scalability of token-based methods with the accuracy of graph-based methods for software functional clone detection. Given a function source code, we first extract the control flow graph by static analysis. Instead of using traditional heavyweight graph matching, we treat the graph as a social network and apply social-network-centrality analysis to dig out the centrality of each basic block. Then we assign the centrality to each token in a basic block and sum the centrality of the same token in different basic blocks. By this, a graph is turned into certain tokens with graph details (i.e., centrality), called semantic tokens. Finally, these semantic tokens are fed into a Siamese architecture neural network to train a code clone detector. We evaluate SCDetector on two large datasets of functionally similar code. Experimental results indicate that our system is superior to four state-of-the-art methods (i.e., SourcererCC, Deckard, RtvNN, and ASTNN) and the time cost of SCDetector is 14 times less than a traditional graph-based method (i.e., CCSharp) on detecting semantic clones.","2020","2022-10-16 23:12:59","2022-10-16 23:12:59","","821–833","","","","","","","ASE '20","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Virtual Event, Australia","","","","semantic tokens; siamese network; social network centrality","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"5UB7A8VE","conferencePaper","2022","Li, Zongjie; Ma, Pingchuan; Wang, Huaijin; Wang, Shuai; Tang, Qiyi; Nie, Sen; Wu, Shi","Unleashing the Power of Compiler Intermediate Representation to Enhance Neural Program Embeddings","Proceedings of the 44th International Conference on Software Engineering","978-1-4503-9221-1","","10.1145/3510003.3510217","https://doi.org/10.1145/3510003.3510217","Neural program embeddings have demonstrated considerable promise in a range of program analysis tasks, including clone identification, program repair, code completion, and program synthesis. However, most existing methods generate neural program embeddings directly from the program source codes, by learning from features such as tokens, abstract syntax trees, and control flow graphs.This paper takes a fresh look at how to improve program embeddings by leveraging compiler intermediate representation (IR). We first demonstrate simple yet highly effective methods for enhancing embedding quality by training embedding models alongside source code and LLVM IR generated by default optimization levels (e.g., -O2). We then introduce IRGen, a framework based on genetic algorithms (GA), to identify (near-)optimal sequences of optimization flags that can significantly improve embedding quality.We use IRGen to find optimal sequences of LLVM optimization flags by performing GA on source code datasets. We then extend a popular code embedding model, CodeCMR, by adding a new objective based on triplet loss to enable a joint learning over source code and LLVM IR. We benchmark the quality of embedding using a representative downstream application, code clone detection. When CodeCMR was trained with source code and LLVM IRs optimized by findings of IRGen, the embedding quality was significantly improved, outperforming the state-of-the-art model, CodeBERT, which was trained only with source code. Our augmented CodeCMR also outperformed CodeCMR trained over source code and IR optimized with default optimization levels. We investigate the properties of optimization flags that increase embedding quality, demonstrate IRGen's generalization in boosting other embedding models, and establish IRGen's use in settings with extremely limited training data. Our research and findings demonstrate that a straightforward addition to modern neural code embedding models can provide a highly effective enhancement.","2022","2022-10-16 23:12:59","2022-10-16 23:12:59","","2253–2265","","","","","","","ICSE '22","","","","Association for Computing Machinery","New York, NY, USA","","","","","","","","event-place: Pittsburgh, Pennsylvania","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"WAIYH2PZ","journalArticle","2021","Keller, Patrick; Kaboré, Abdoul Kader; Plein, Laura; Klein, Jacques; Le Traon, Yves; Bissyandé, Tegawendé F.","What You See is What It Means! Semantic Representation Learning of Code Based on Visualization and Transfer Learning","ACM Trans. Softw. Eng. Methodol.","","1049-331X","10.1145/3485135","https://doi.org/10.1145/3485135","Recent successes in training word embeddings for Natural Language Processing (NLP) tasks have encouraged a wave of research on representation learning for source code, which builds on similar NLP methods. The overall objective is then to produce code embeddings that capture the maximum of program semantics. State-of-the-art approaches invariably rely on a syntactic representation (i.e., raw lexical tokens, abstract syntax trees, or intermediate representation tokens) to generate embeddings, which are criticized in the literature as non-robust or non-generalizable. In this work, we investigate a novel embedding approach based on the intuition that source code has visual patterns of semantics. We further use these patterns to address the outstanding challenge of identifying semantic code clones. We propose the WySiWiM&nbsp;(‘‘What You See Is What It Means”) approach where visual representations of source code are fed into powerful pre-trained image classification neural networks from the field of computer vision to benefit from the practical advantages of transfer learning. We evaluate the proposed embedding approach on the task of vulnerable code prediction in source code and on two variations of the task of semantic code clone identification: code clone detection (a binary classification problem), and code classification (a multi-classification problem). We show with experiments on the BigCloneBench (Java), Open Judge (C) that although simple, our WySiWiM &nbsp;approach performs as effectively as state-of-the-art approaches such as ASTNN or TBCNN. We also showed with data from NVD and SARD that WySiWiM &nbsp;representation can be used to learn a vulnerable code detector with reasonable performance (accuracy ∼90%). We further explore the influence of different steps in our approach, such as the choice of visual representations or the classification algorithm, to eventually discuss the promises and limitations of this research direction.","2021-12","2022-10-16 23:12:59","2022-10-16 23:12:59","","","","2","31","","","","","","","","","","","","","","","","","Place: New York, NY, USA Publisher: Association for Computing Machinery","","","","Semantic clones; embedding; representation learning; visual representation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""